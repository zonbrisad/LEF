   1               		.file	"LEF_Queue.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  11               	LEF_QueueSend.part.1:
  12               	.LFB19:
  13               		.file 1 "src/LEF/LEF_Queue.c"
   1:src/LEF/LEF_Queue.c **** /**
   2:src/LEF/LEF_Queue.c ****  * LEF - Lightweight Event Framework
   3:src/LEF/LEF_Queue.c ****  *
   4:src/LEF/LEF_Queue.c ****  * This file is part of LEF distribution
   5:src/LEF/LEF_Queue.c ****  *
   6:src/LEF/LEF_Queue.c ****  *---------------------------------------------------------------------------
   7:src/LEF/LEF_Queue.c ****  * @brief   Queue functions
   8:src/LEF/LEF_Queue.c ****  *
   9:src/LEF/LEF_Queue.c ****  * @file    LEF_Queue.c
  10:src/LEF/LEF_Queue.c ****  * @author  Peter Malmberg <peter.malmberg@gmail.com>
  11:src/LEF/LEF_Queue.c ****  * @date    2016-12-08
  12:src/LEF/LEF_Queue.c ****  * @licence GPLv2
  13:src/LEF/LEF_Queue.c ****  *
  14:src/LEF/LEF_Queue.c ****  *---------------------------------------------------------------------------
  15:src/LEF/LEF_Queue.c ****  *
  16:src/LEF/LEF_Queue.c ****  * LEF is distributed in the hope that it will be useful, but WITHOUT ANY
  17:src/LEF/LEF_Queue.c ****  * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  18:src/LEF/LEF_Queue.c ****  * FOR A PARTICULAR PURPOSE.  Full license text is available on the following
  19:src/LEF/LEF_Queue.c ****  *
  20:src/LEF/LEF_Queue.c ****  * Source repository:
  21:src/LEF/LEF_Queue.c ****  * https://github.com/zonbrisad/LEF
  22:src/LEF/LEF_Queue.c ****  *
  23:src/LEF/LEF_Queue.c ****  * 1 tab = 2 spaces
  24:src/LEF/LEF_Queue.c ****  */
  25:src/LEF/LEF_Queue.c **** 
  26:src/LEF/LEF_Queue.c **** // Includes ---------------------------------------------------------------
  27:src/LEF/LEF_Queue.c **** #include "LEF.h"
  28:src/LEF/LEF_Queue.c **** #include "LEF_Queue.h"
  29:src/LEF/LEF_Queue.c **** 
  30:src/LEF/LEF_Queue.c **** // Macros -----------------------------------------------------------------
  31:src/LEF/LEF_Queue.c **** 
  32:src/LEF/LEF_Queue.c **** // Variables --------------------------------------------------------------
  33:src/LEF/LEF_Queue.c **** LEF_EventQueue StdQueue;
  34:src/LEF/LEF_Queue.c **** 
  35:src/LEF/LEF_Queue.c **** // Prototypes -------------------------------------------------------------
  36:src/LEF/LEF_Queue.c **** void LEF_element_cpy(LEF_queue_element *dst, LEF_queue_element *src);
  37:src/LEF/LEF_Queue.c **** uint8_t queue_ptr_inc(uint8_t ptr);
  38:src/LEF/LEF_Queue.c **** // Code -------------------------------------------------------------------
  39:src/LEF/LEF_Queue.c **** 
  40:src/LEF/LEF_Queue.c **** 
  41:src/LEF/LEF_Queue.c **** 
  42:src/LEF/LEF_Queue.c **** void LEF_QueueClear(LEF_EventQueue *queue) {
  43:src/LEF/LEF_Queue.c ****   queue->head = 0;
  44:src/LEF/LEF_Queue.c ****   queue->cnt  = 0;
  45:src/LEF/LEF_Queue.c **** }
  46:src/LEF/LEF_Queue.c **** 
  47:src/LEF/LEF_Queue.c **** void LEF_element_cpy(LEF_queue_element *dst, LEF_queue_element *src) {
  48:src/LEF/LEF_Queue.c ****   dst->id = src->id;
  49:src/LEF/LEF_Queue.c ****   dst->func   = src->func;
  50:src/LEF/LEF_Queue.c **** }
  51:src/LEF/LEF_Queue.c **** 
  52:src/LEF/LEF_Queue.c **** void LEF_QueueInit(LEF_EventQueue *queue) {
  53:src/LEF/LEF_Queue.c **** 	LEF_QueueClear(queue);
  54:src/LEF/LEF_Queue.c **** }
  55:src/LEF/LEF_Queue.c **** 
  56:src/LEF/LEF_Queue.c **** uint8_t queue_ptr_inc(uint8_t ptr) {
  57:src/LEF/LEF_Queue.c ****   return ptr % LEF_QUEUE_LENGTH;
  58:src/LEF/LEF_Queue.c **** }
  59:src/LEF/LEF_Queue.c **** 
  60:src/LEF/LEF_Queue.c **** void LEF_QueueSend(LEF_EventQueue *queue,  LEF_queue_element *qe) {
  14               		.loc 1 60 0
  15               		.cfi_startproc
  16               	.LVL0:
  17 0000 CF93      		push r28
  18               	.LCFI0:
  19               		.cfi_def_cfa_offset 3
  20               		.cfi_offset 28, -2
  21 0002 DF93      		push r29
  22               	.LCFI1:
  23               		.cfi_def_cfa_offset 4
  24               		.cfi_offset 29, -3
  25               	/* prologue: function */
  26               	/* frame size = 0 */
  27               	/* stack size = 2 */
  28               	.L__stack_usage = 2
  29 0004 FC01      		movw r30,r24
  30               	.LVL1:
  31               	.LBB48:
  61:src/LEF/LEF_Queue.c **** 
  62:src/LEF/LEF_Queue.c **** //
  63:src/LEF/LEF_Queue.c **** //  if (queue->tail==255)         // detect initial condition and set to zero
  64:src/LEF/LEF_Queue.c **** //    queue->tail=0;
  65:src/LEF/LEF_Queue.c **** 
  66:src/LEF/LEF_Queue.c ****   if (queue->cnt==LEF_QUEUE_LENGTH)         // detect initial condition and set to zero
  67:src/LEF/LEF_Queue.c ****     return;
  68:src/LEF/LEF_Queue.c **** 
  69:src/LEF/LEF_Queue.c **** //  if (queue->tail==queue->head) // if queue is full return
  70:src/LEF/LEF_Queue.c **** //    return;
  71:src/LEF/LEF_Queue.c **** 
  72:src/LEF/LEF_Queue.c ****   LEF_ATOMIC_BLOCK() {
  73:src/LEF/LEF_Queue.c ****   //LEF_EnterCritical();
  74:src/LEF/LEF_Queue.c **** 	  LEF_element_cpy(&queue->que[queue->head], qe);
  32               		.loc 1 74 0
  33 0006 8489      		ldd r24,Z+20
  34               	.LVL2:
  35 0008 A82F      		mov r26,r24
  36 000a B0E0      		ldi r27,0
  37               	.LVL3:
  38               	.LBB49:
  39               	.LBB50:
  48:src/LEF/LEF_Queue.c ****   dst->func   = src->func;
  40               		.loc 1 48 0
  41 000c EB01      		movw r28,r22
  42 000e 9881      		ld r25,Y
  43 0010 AA0F      		lsl r26
  44 0012 BB1F      		rol r27
  45               	.LVL4:
  46 0014 AE0F      		add r26,r30
  47 0016 BF1F      		adc r27,r31
  48               	.LVL5:
  49 0018 9C93      		st X,r25
  49:src/LEF/LEF_Queue.c **** }
  50               		.loc 1 49 0
  51 001a 9981      		ldd r25,Y+1
  52 001c 1196      		adiw r26,1
  53 001e 9C93      		st X,r25
  54               	.LVL6:
  55               	.LBE50:
  56               	.LBE49:
  75:src/LEF/LEF_Queue.c **** 
  76:src/LEF/LEF_Queue.c ****     queue->cnt++;
  57               		.loc 1 76 0
  58 0020 9589      		ldd r25,Z+21
  59 0022 9F5F      		subi r25,lo8(-(1))
  60 0024 958B      		std Z+21,r25
  77:src/LEF/LEF_Queue.c ****     queue->head++;
  61               		.loc 1 77 0
  62 0026 8F5F      		subi r24,lo8(-(1))
  78:src/LEF/LEF_Queue.c ****     if (queue->head>=LEF_QUEUE_LENGTH)
  63               		.loc 1 78 0
  64 0028 8A30      		cpi r24,lo8(10)
  65 002a 00F0      		brlo .L5
  79:src/LEF/LEF_Queue.c ****       queue->head = 0;
  66               		.loc 1 79 0
  67 002c 148A      		std Z+20,__zero_reg__
  68               	.LVL7:
  69               	.LBB51:
  70               	.LBB52:
  71               		.file 2 "/usr/lib/avr/include/util/atomic.h"
   1:/usr/lib/avr/include/util/atomic.h **** /* Copyright (c) 2007 Dean Camera
   2:/usr/lib/avr/include/util/atomic.h ****    All rights reserved.
   3:/usr/lib/avr/include/util/atomic.h **** 
   4:/usr/lib/avr/include/util/atomic.h ****    Redistribution and use in source and binary forms, with or without
   5:/usr/lib/avr/include/util/atomic.h ****    modification, are permitted provided that the following conditions are met:
   6:/usr/lib/avr/include/util/atomic.h **** 
   7:/usr/lib/avr/include/util/atomic.h ****    * Redistributions of source code must retain the above copyright
   8:/usr/lib/avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer.
   9:/usr/lib/avr/include/util/atomic.h **** 
  10:/usr/lib/avr/include/util/atomic.h ****    * Redistributions in binary form must reproduce the above copyright
  11:/usr/lib/avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer in
  12:/usr/lib/avr/include/util/atomic.h ****      the documentation and/or other materials provided with the
  13:/usr/lib/avr/include/util/atomic.h ****      distribution.
  14:/usr/lib/avr/include/util/atomic.h **** 
  15:/usr/lib/avr/include/util/atomic.h ****    * Neither the name of the copyright holders nor the names of
  16:/usr/lib/avr/include/util/atomic.h ****      contributors may be used to endorse or promote products derived
  17:/usr/lib/avr/include/util/atomic.h ****      from this software without specific prior written permission.
  18:/usr/lib/avr/include/util/atomic.h **** 
  19:/usr/lib/avr/include/util/atomic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20:/usr/lib/avr/include/util/atomic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21:/usr/lib/avr/include/util/atomic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22:/usr/lib/avr/include/util/atomic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23:/usr/lib/avr/include/util/atomic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24:/usr/lib/avr/include/util/atomic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25:/usr/lib/avr/include/util/atomic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26:/usr/lib/avr/include/util/atomic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27:/usr/lib/avr/include/util/atomic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28:/usr/lib/avr/include/util/atomic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29:/usr/lib/avr/include/util/atomic.h ****   POSSIBILITY OF SUCH DAMAGE.
  30:/usr/lib/avr/include/util/atomic.h **** */
  31:/usr/lib/avr/include/util/atomic.h **** 
  32:/usr/lib/avr/include/util/atomic.h **** /* $Id$ */
  33:/usr/lib/avr/include/util/atomic.h **** 
  34:/usr/lib/avr/include/util/atomic.h **** #ifndef _UTIL_ATOMIC_H_
  35:/usr/lib/avr/include/util/atomic.h **** #define _UTIL_ATOMIC_H_ 1
  36:/usr/lib/avr/include/util/atomic.h **** 
  37:/usr/lib/avr/include/util/atomic.h **** #include <avr/io.h>
  38:/usr/lib/avr/include/util/atomic.h **** #include <avr/interrupt.h>
  39:/usr/lib/avr/include/util/atomic.h **** 
  40:/usr/lib/avr/include/util/atomic.h **** #if !defined(__DOXYGEN__)
  41:/usr/lib/avr/include/util/atomic.h **** /* Internal helper functions. */
  42:/usr/lib/avr/include/util/atomic.h **** static __inline__ uint8_t __iSeiRetVal(void)
  43:/usr/lib/avr/include/util/atomic.h **** {
  44:/usr/lib/avr/include/util/atomic.h ****     sei();
  45:/usr/lib/avr/include/util/atomic.h ****     return 1;
  46:/usr/lib/avr/include/util/atomic.h **** }
  47:/usr/lib/avr/include/util/atomic.h **** 
  48:/usr/lib/avr/include/util/atomic.h **** static __inline__ uint8_t __iCliRetVal(void)
  49:/usr/lib/avr/include/util/atomic.h **** {
  50:/usr/lib/avr/include/util/atomic.h ****     cli();
  51:/usr/lib/avr/include/util/atomic.h ****     return 1;
  52:/usr/lib/avr/include/util/atomic.h **** }
  53:/usr/lib/avr/include/util/atomic.h **** 
  54:/usr/lib/avr/include/util/atomic.h **** static __inline__ void __iSeiParam(const uint8_t *__s)
  55:/usr/lib/avr/include/util/atomic.h **** {
  56:/usr/lib/avr/include/util/atomic.h ****     sei();
  72               		.loc 2 56 0
  73               	/* #APP */
  74               	 ;  56 "/usr/lib/avr/include/util/atomic.h" 1
  75 002e 7894      		sei
  76               	 ;  0 "" 2
  57:/usr/lib/avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  77               		.loc 2 57 0
  78               	.LVL8:
  79               	/* epilogue start */
  80               	/* #NOAPP */
  81               	.LBE52:
  82               	.LBE51:
  83               	.LBE48:
  80:src/LEF/LEF_Queue.c ****     }
  81:src/LEF/LEF_Queue.c ****    //LEF_ExitCritical();
  82:src/LEF/LEF_Queue.c **** }
  84               		.loc 1 82 0
  85 0030 DF91      		pop r29
  86 0032 CF91      		pop r28
  87 0034 0895      		ret
  88               	.LVL9:
  89               	.L5:
  90               	.LBB55:
  77:src/LEF/LEF_Queue.c ****     if (queue->head>=LEF_QUEUE_LENGTH)
  91               		.loc 1 77 0
  92 0036 848B      		std Z+20,r24
  93               	.LVL10:
  94               	.LBB54:
  95               	.LBB53:
  56:/usr/lib/avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  96               		.loc 2 56 0
  97               	/* #APP */
  98               	 ;  56 "/usr/lib/avr/include/util/atomic.h" 1
  99 0038 7894      		sei
 100               	 ;  0 "" 2
 101               		.loc 2 57 0
 102               	/* epilogue start */
 103               	/* #NOAPP */
 104               	.LBE53:
 105               	.LBE54:
 106               	.LBE55:
 107               		.loc 1 82 0
 108 003a DF91      		pop r29
 109 003c CF91      		pop r28
 110 003e 0895      		ret
 111               		.cfi_endproc
 112               	.LFE19:
 114               	.global	LEF_QueueClear
 116               	LEF_QueueClear:
 117               	.LFB21:
 118               		.cfi_startproc
 119               	/* prologue: function */
 120               	/* frame size = 0 */
 121               	/* stack size = 0 */
 122               	.L__stack_usage = 0
 123 0040 FC01      		movw r30,r24
 124 0042 148A      		std Z+20,__zero_reg__
 125 0044 158A      		std Z+21,__zero_reg__
 126 0046 0895      		ret
 127               		.cfi_endproc
 128               	.LFE21:
 130               	.global	LEF_element_cpy
 132               	LEF_element_cpy:
 133               	.LFB7:
  47:src/LEF/LEF_Queue.c ****   dst->id = src->id;
 134               		.loc 1 47 0
 135               		.cfi_startproc
 136               	.LVL11:
 137               	/* prologue: function */
 138               	/* frame size = 0 */
 139               	/* stack size = 0 */
 140               	.L__stack_usage = 0
  48:src/LEF/LEF_Queue.c ****   dst->func   = src->func;
 141               		.loc 1 48 0
 142 0048 FB01      		movw r30,r22
 143 004a 2081      		ld r18,Z
 144 004c FC01      		movw r30,r24
 145 004e 2083      		st Z,r18
  49:src/LEF/LEF_Queue.c **** }
 146               		.loc 1 49 0
 147 0050 FB01      		movw r30,r22
 148 0052 2181      		ldd r18,Z+1
 149 0054 FC01      		movw r30,r24
 150 0056 2183      		std Z+1,r18
 151 0058 0895      		ret
 152               		.cfi_endproc
 153               	.LFE7:
 155               	.global	LEF_QueueInit
 157               	LEF_QueueInit:
 158               	.LFB8:
  52:src/LEF/LEF_Queue.c **** 	LEF_QueueClear(queue);
 159               		.loc 1 52 0
 160               		.cfi_startproc
 161               	.LVL12:
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
 166               	.LBB56:
 167               	.LBB57:
  43:src/LEF/LEF_Queue.c ****   queue->cnt  = 0;
 168               		.loc 1 43 0
 169 005a FC01      		movw r30,r24
 170 005c 148A      		std Z+20,__zero_reg__
  44:src/LEF/LEF_Queue.c **** }
 171               		.loc 1 44 0
 172 005e 158A      		std Z+21,__zero_reg__
 173               	.LVL13:
 174 0060 0895      		ret
 175               	.LBE57:
 176               	.LBE56:
 177               		.cfi_endproc
 178               	.LFE8:
 180               	.global	queue_ptr_inc
 182               	queue_ptr_inc:
 183               	.LFB9:
  56:src/LEF/LEF_Queue.c ****   return ptr % LEF_QUEUE_LENGTH;
 184               		.loc 1 56 0
 185               		.cfi_startproc
 186               	.LVL14:
 187               	/* prologue: function */
 188               	/* frame size = 0 */
 189               	/* stack size = 0 */
 190               	.L__stack_usage = 0
  57:src/LEF/LEF_Queue.c **** }
 191               		.loc 1 57 0
 192 0062 9DEC      		ldi r25,lo8(-51)
 193 0064 899F      		mul r24,r25
 194 0066 912D      		mov r25,r1
 195 0068 1124      		clr __zero_reg__
 196 006a 9695      		lsr r25
 197 006c 9695      		lsr r25
 198 006e 9695      		lsr r25
  58:src/LEF/LEF_Queue.c **** 
 199               		.loc 1 58 0
 200 0070 2AE0      		ldi r18,lo8(10)
 201 0072 929F      		mul r25,r18
 202 0074 8019      		sub r24,r0
 203 0076 1124      		clr __zero_reg__
 204               	.LVL15:
 205 0078 0895      		ret
 206               		.cfi_endproc
 207               	.LFE9:
 209               	.global	LEF_QueueSend
 211               	LEF_QueueSend:
 212               	.LFB10:
  60:src/LEF/LEF_Queue.c **** 
 213               		.loc 1 60 0
 214               		.cfi_startproc
 215               	.LVL16:
 216               	/* prologue: function */
 217               	/* frame size = 0 */
 218               	/* stack size = 0 */
 219               	.L__stack_usage = 0
  66:src/LEF/LEF_Queue.c ****     return;
 220               		.loc 1 66 0
 221 007a FC01      		movw r30,r24
 222 007c 2589      		ldd r18,Z+21
 223 007e 2A30      		cpi r18,lo8(10)
 224 0080 01F0      		breq .L10
 225               	.LVL17:
 226               	.LBB58:
 227               	.LBB59:
 228               	.LBB60:
  50:/usr/lib/avr/include/util/atomic.h ****     return 1;
 229               		.loc 2 50 0
 230               	/* #APP */
 231               	 ;  50 "/usr/lib/avr/include/util/atomic.h" 1
 232 0082 F894      		cli
 233               	 ;  0 "" 2
 234               	/* #NOAPP */
 235               	.LBE60:
 236               	.LBE59:
 237               	.LBE58:
 238 0084 0C94 0000 		jmp LEF_QueueSend.part.1
 239               	.LVL18:
 240               	.L10:
 241 0088 0895      		ret
 242               		.cfi_endproc
 243               	.LFE10:
 245               	.global	LEF_QueueWait
 247               	LEF_QueueWait:
 248               	.LFB11:
  83:src/LEF/LEF_Queue.c **** 
  84:src/LEF/LEF_Queue.c **** void LEF_QueueWait(LEF_EventQueue *queue, LEF_queue_element *qe) {
 249               		.loc 1 84 0
 250               		.cfi_startproc
 251               	.LVL19:
 252 008a CF93      		push r28
 253               	.LCFI2:
 254               		.cfi_def_cfa_offset 3
 255               		.cfi_offset 28, -2
 256 008c DF93      		push r29
 257               	.LCFI3:
 258               		.cfi_def_cfa_offset 4
 259               		.cfi_offset 29, -3
 260               	/* prologue: function */
 261               	/* frame size = 0 */
 262               	/* stack size = 2 */
 263               	.L__stack_usage = 2
 264 008e EC01      		movw r28,r24
 265 0090 9B01      		movw r18,r22
 266               	.LVL20:
 267               	.L13:
  85:src/LEF/LEF_Queue.c **** 
  86:src/LEF/LEF_Queue.c ****   while(queue->cnt==0) {               // wait until queue has an element
 268               		.loc 1 86 0 discriminator 1
 269 0092 8D89      		ldd r24,Y+21
 270 0094 8823      		tst r24
 271 0096 01F0      		breq .L13
 272               	.LVL21:
 273               	.LBB61:
 274               	.LBB62:
 275               	.LBB63:
  50:/usr/lib/avr/include/util/atomic.h ****     return 1;
 276               		.loc 2 50 0
 277               	/* #APP */
 278               	 ;  50 "/usr/lib/avr/include/util/atomic.h" 1
 279 0098 F894      		cli
 280               	 ;  0 "" 2
 281               	.LVL22:
 282               	/* #NOAPP */
 283               	.LBE63:
 284               	.LBE62:
  87:src/LEF/LEF_Queue.c ****   }
  88:src/LEF/LEF_Queue.c **** 
  89:src/LEF/LEF_Queue.c ****   LEF_ATOMIC_BLOCK() {
  90:src/LEF/LEF_Queue.c **** 	  LEF_element_cpy(qe, &queue->que[(queue->head+(LEF_QUEUE_LENGTH-queue->cnt))%LEF_QUEUE_LENGTH]);
 285               		.loc 1 90 0
 286 009a 8D89      		ldd r24,Y+21
 287 009c 4C89      		ldd r20,Y+20
 288 009e 6AE0      		ldi r22,lo8(10)
 289 00a0 70E0      		ldi r23,0
 290               	.LVL23:
 291 00a2 DB01      		movw r26,r22
 292 00a4 A81B      		sub r26,r24
 293 00a6 B109      		sbc r27,__zero_reg__
 294 00a8 CD01      		movw r24,r26
 295 00aa 840F      		add r24,r20
 296 00ac 911D      		adc r25,__zero_reg__
 297 00ae 0E94 0000 		call __divmodhi4
 298               	.LVL24:
 299               	.LBB64:
 300               	.LBB65:
  48:src/LEF/LEF_Queue.c ****   dst->func   = src->func;
 301               		.loc 1 48 0
 302 00b2 FC01      		movw r30,r24
 303 00b4 EE0F      		lsl r30
 304 00b6 FF1F      		rol r31
 305               	.LVL25:
 306 00b8 EC0F      		add r30,r28
 307 00ba FD1F      		adc r31,r29
 308               	.LVL26:
 309 00bc 8081      		ld r24,Z
 310 00be D901      		movw r26,r18
 311 00c0 8C93      		st X,r24
  49:src/LEF/LEF_Queue.c **** }
 312               		.loc 1 49 0
 313 00c2 8181      		ldd r24,Z+1
 314 00c4 1196      		adiw r26,1
 315 00c6 8C93      		st X,r24
 316               	.LVL27:
 317               	.LBE65:
 318               	.LBE64:
  91:src/LEF/LEF_Queue.c ****     queue->cnt--;
 319               		.loc 1 91 0
 320 00c8 8D89      		ldd r24,Y+21
 321 00ca 8150      		subi r24,lo8(-(-1))
 322 00cc 8D8B      		std Y+21,r24
 323               	.LVL28:
 324               	.LBB66:
 325               	.LBB67:
  56:/usr/lib/avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
 326               		.loc 2 56 0
 327               	/* #APP */
 328               	 ;  56 "/usr/lib/avr/include/util/atomic.h" 1
 329 00ce 7894      		sei
 330               	 ;  0 "" 2
 331               		.loc 2 57 0
 332               	.LVL29:
 333               	/* epilogue start */
 334               	/* #NOAPP */
 335               	.LBE67:
 336               	.LBE66:
 337               	.LBE61:
  92:src/LEF/LEF_Queue.c ****   }
  93:src/LEF/LEF_Queue.c **** 
  94:src/LEF/LEF_Queue.c **** }
 338               		.loc 1 94 0
 339 00d0 DF91      		pop r29
 340 00d2 CF91      		pop r28
 341               	.LVL30:
 342 00d4 0895      		ret
 343               		.cfi_endproc
 344               	.LFE11:
 346               	.global	LEF_QueueSendEvent
 348               	LEF_QueueSendEvent:
 349               	.LFB12:
  95:src/LEF/LEF_Queue.c **** 
  96:src/LEF/LEF_Queue.c **** /**
  97:src/LEF/LEF_Queue.c ****  * @todo add support for extra data
  98:src/LEF/LEF_Queue.c ****  */
  99:src/LEF/LEF_Queue.c **** void LEF_QueueSendEvent(LEF_EventQueue *queue, LEF_EventId ev, void *data) {
 350               		.loc 1 99 0
 351               		.cfi_startproc
 352               	.LVL31:
 353 00d6 CF93      		push r28
 354               	.LCFI4:
 355               		.cfi_def_cfa_offset 3
 356               		.cfi_offset 28, -2
 357 00d8 DF93      		push r29
 358               	.LCFI5:
 359               		.cfi_def_cfa_offset 4
 360               		.cfi_offset 29, -3
 361 00da 00D0      		rcall .
 362               	.LCFI6:
 363               		.cfi_def_cfa_offset 6
 364 00dc CDB7      		in r28,__SP_L__
 365 00de DEB7      		in r29,__SP_H__
 366               	.LCFI7:
 367               		.cfi_def_cfa_register 28
 368               	/* prologue: function */
 369               	/* frame size = 2 */
 370               	/* stack size = 4 */
 371               	.L__stack_usage = 4
 100:src/LEF/LEF_Queue.c ****   LEF_queue_element qe;
 101:src/LEF/LEF_Queue.c ****   (void) data;
 102:src/LEF/LEF_Queue.c ****   qe.id = ev;
 372               		.loc 1 102 0
 373 00e0 6983      		std Y+1,r22
 374               	.LVL32:
 375               	.LBB68:
 376               	.LBB69:
  66:src/LEF/LEF_Queue.c ****     return;
 377               		.loc 1 66 0
 378 00e2 FC01      		movw r30,r24
 379 00e4 2589      		ldd r18,Z+21
 380 00e6 2A30      		cpi r18,lo8(10)
 381 00e8 01F0      		breq .L16
 382               	.LVL33:
 383               	.LBB70:
 384               	.LBB71:
 385               	.LBB72:
  50:/usr/lib/avr/include/util/atomic.h ****     return 1;
 386               		.loc 2 50 0
 387               	/* #APP */
 388               	 ;  50 "/usr/lib/avr/include/util/atomic.h" 1
 389 00ea F894      		cli
 390               	 ;  0 "" 2
 391               	/* #NOAPP */
 392               	.LBE72:
 393               	.LBE71:
 394               	.LBE70:
 395 00ec BE01      		movw r22,r28
 396               	.LVL34:
 397 00ee 6F5F      		subi r22,-1
 398 00f0 7F4F      		sbci r23,-1
 399 00f2 0E94 0000 		call LEF_QueueSend.part.1
 400               	.LVL35:
 401               	.L16:
 402               	/* epilogue start */
 403               	.LBE69:
 404               	.LBE68:
 103:src/LEF/LEF_Queue.c ****   LEF_QueueSend(queue, &qe);
 104:src/LEF/LEF_Queue.c **** }
 405               		.loc 1 104 0
 406 00f6 0F90      		pop __tmp_reg__
 407 00f8 0F90      		pop __tmp_reg__
 408 00fa DF91      		pop r29
 409 00fc CF91      		pop r28
 410 00fe 0895      		ret
 411               		.cfi_endproc
 412               	.LFE12:
 414               	.global	LEF_QueueCnt
 416               	LEF_QueueCnt:
 417               	.LFB13:
 105:src/LEF/LEF_Queue.c **** 
 106:src/LEF/LEF_Queue.c **** 
 107:src/LEF/LEF_Queue.c **** uint16_t LEF_QueueCnt(LEF_EventQueue *queue) {
 418               		.loc 1 107 0
 419               		.cfi_startproc
 420               	.LVL36:
 421               	/* prologue: function */
 422               	/* frame size = 0 */
 423               	/* stack size = 0 */
 424               	.L__stack_usage = 0
 108:src/LEF/LEF_Queue.c ****   return queue->cnt;
 425               		.loc 1 108 0
 426 0100 FC01      		movw r30,r24
 427 0102 8589      		ldd r24,Z+21
 428               	.LVL37:
 109:src/LEF/LEF_Queue.c **** }
 429               		.loc 1 109 0
 430 0104 90E0      		ldi r25,0
 431 0106 0895      		ret
 432               		.cfi_endproc
 433               	.LFE13:
 435               	.global	LEF_QueueStdSend
 437               	LEF_QueueStdSend:
 438               	.LFB14:
 110:src/LEF/LEF_Queue.c **** 
 111:src/LEF/LEF_Queue.c **** 
 112:src/LEF/LEF_Queue.c **** void LEF_QueueStdSend(LEF_queue_element *qe) {
 439               		.loc 1 112 0
 440               		.cfi_startproc
 441               	.LVL38:
 442               	/* prologue: function */
 443               	/* frame size = 0 */
 444               	/* stack size = 0 */
 445               	.L__stack_usage = 0
 446 0108 BC01      		movw r22,r24
 447               	.LVL39:
 448               	.LBB73:
 449               	.LBB74:
  66:src/LEF/LEF_Queue.c ****     return;
 450               		.loc 1 66 0
 451 010a 9091 0000 		lds r25,StdQueue+21
 452 010e 9A30      		cpi r25,lo8(10)
 453 0110 01F0      		breq .L22
 454               	.LVL40:
 455               	.LBB75:
 456               	.LBB76:
 457               	.LBB77:
  50:/usr/lib/avr/include/util/atomic.h ****     return 1;
 458               		.loc 2 50 0
 459               	/* #APP */
 460               	 ;  50 "/usr/lib/avr/include/util/atomic.h" 1
 461 0112 F894      		cli
 462               	 ;  0 "" 2
 463               	/* #NOAPP */
 464               	.LBE77:
 465               	.LBE76:
 466               	.LBE75:
 467 0114 80E0      		ldi r24,lo8(StdQueue)
 468 0116 90E0      		ldi r25,hi8(StdQueue)
 469               	.LVL41:
 470 0118 0C94 0000 		jmp LEF_QueueSend.part.1
 471               	.LVL42:
 472               	.L22:
 473 011c 0895      		ret
 474               	.LBE74:
 475               	.LBE73:
 476               		.cfi_endproc
 477               	.LFE14:
 479               	.global	LEF_QueueStdWait
 481               	LEF_QueueStdWait:
 482               	.LFB15:
 113:src/LEF/LEF_Queue.c **** 	return LEF_QueueSend(&StdQueue, qe);
 114:src/LEF/LEF_Queue.c **** }
 115:src/LEF/LEF_Queue.c **** 
 116:src/LEF/LEF_Queue.c **** void LEF_QueueStdWait(LEF_queue_element *qe) {
 483               		.loc 1 116 0
 484               		.cfi_startproc
 485               	.LVL43:
 486 011e CF93      		push r28
 487               	.LCFI8:
 488               		.cfi_def_cfa_offset 3
 489               		.cfi_offset 28, -2
 490 0120 DF93      		push r29
 491               	.LCFI9:
 492               		.cfi_def_cfa_offset 4
 493               		.cfi_offset 29, -3
 494               	/* prologue: function */
 495               	/* frame size = 0 */
 496               	/* stack size = 2 */
 497               	.L__stack_usage = 2
 498 0122 EC01      		movw r28,r24
 499               	.LVL44:
 500               	.L25:
 501               	.LBB78:
 502               	.LBB79:
  86:src/LEF/LEF_Queue.c ****   }
 503               		.loc 1 86 0
 504 0124 8091 0000 		lds r24,StdQueue+21
 505 0128 8823      		tst r24
 506 012a 01F0      		breq .L25
 507               	.LVL45:
 508               	.LBB80:
 509               	.LBB81:
 510               	.LBB82:
  50:/usr/lib/avr/include/util/atomic.h ****     return 1;
 511               		.loc 2 50 0
 512               	/* #APP */
 513               	 ;  50 "/usr/lib/avr/include/util/atomic.h" 1
 514 012c F894      		cli
 515               	 ;  0 "" 2
 516               	.LVL46:
 517               	/* #NOAPP */
 518               	.LBE82:
 519               	.LBE81:
  90:src/LEF/LEF_Queue.c ****     queue->cnt--;
 520               		.loc 1 90 0
 521 012e 8091 0000 		lds r24,StdQueue+21
 522 0132 2091 0000 		lds r18,StdQueue+20
 523 0136 6AE0      		ldi r22,lo8(10)
 524 0138 70E0      		ldi r23,0
 525 013a AB01      		movw r20,r22
 526 013c 481B      		sub r20,r24
 527 013e 5109      		sbc r21,__zero_reg__
 528 0140 CA01      		movw r24,r20
 529 0142 820F      		add r24,r18
 530 0144 911D      		adc r25,__zero_reg__
 531 0146 0E94 0000 		call __divmodhi4
 532               	.LVL47:
 533               	.LBB83:
 534               	.LBB84:
  48:src/LEF/LEF_Queue.c ****   dst->func   = src->func;
 535               		.loc 1 48 0
 536 014a FC01      		movw r30,r24
 537 014c EE0F      		lsl r30
 538 014e FF1F      		rol r31
 539               	.LVL48:
 540 0150 E050      		subi r30,lo8(-(StdQueue))
 541 0152 F040      		sbci r31,hi8(-(StdQueue))
 542               	.LVL49:
 543 0154 8081      		ld r24,Z
 544 0156 8883      		st Y,r24
  49:src/LEF/LEF_Queue.c **** }
 545               		.loc 1 49 0
 546 0158 8181      		ldd r24,Z+1
 547 015a 8983      		std Y+1,r24
 548               	.LVL50:
 549               	.LBE84:
 550               	.LBE83:
  91:src/LEF/LEF_Queue.c ****   }
 551               		.loc 1 91 0
 552 015c 8091 0000 		lds r24,StdQueue+21
 553 0160 8150      		subi r24,lo8(-(-1))
 554 0162 8093 0000 		sts StdQueue+21,r24
 555               	.LVL51:
 556               	.LBB85:
 557               	.LBB86:
  56:/usr/lib/avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
 558               		.loc 2 56 0
 559               	/* #APP */
 560               	 ;  56 "/usr/lib/avr/include/util/atomic.h" 1
 561 0166 7894      		sei
 562               	 ;  0 "" 2
 563               		.loc 2 57 0
 564               	.LVL52:
 565               	/* epilogue start */
 566               	/* #NOAPP */
 567               	.LBE86:
 568               	.LBE85:
 569               	.LBE80:
 570               	.LBE79:
 571               	.LBE78:
 117:src/LEF/LEF_Queue.c **** 	return LEF_QueueWait(&StdQueue, qe);
 118:src/LEF/LEF_Queue.c **** }
 572               		.loc 1 118 0
 573 0168 DF91      		pop r29
 574 016a CF91      		pop r28
 575               	.LVL53:
 576 016c 0895      		ret
 577               		.cfi_endproc
 578               	.LFE15:
 580               	.global	LEF_QueueStdClear
 582               	LEF_QueueStdClear:
 583               	.LFB16:
 119:src/LEF/LEF_Queue.c **** 
 120:src/LEF/LEF_Queue.c **** void LEF_QueueStdClear(void) {
 584               		.loc 1 120 0
 585               		.cfi_startproc
 586               	/* prologue: function */
 587               	/* frame size = 0 */
 588               	/* stack size = 0 */
 589               	.L__stack_usage = 0
 590               	.LVL54:
 591               	.LBB87:
 592               	.LBB88:
  43:src/LEF/LEF_Queue.c ****   queue->cnt  = 0;
 593               		.loc 1 43 0
 594 016e E0E0      		ldi r30,lo8(StdQueue)
 595 0170 F0E0      		ldi r31,hi8(StdQueue)
 596 0172 148A      		std Z+20,__zero_reg__
  44:src/LEF/LEF_Queue.c **** }
 597               		.loc 1 44 0
 598 0174 158A      		std Z+21,__zero_reg__
 599               	.LVL55:
 600 0176 0895      		ret
 601               	.LBE88:
 602               	.LBE87:
 603               		.cfi_endproc
 604               	.LFE16:
 606               	.global	LEF_QueueStdCnt
 608               	LEF_QueueStdCnt:
 609               	.LFB17:
 121:src/LEF/LEF_Queue.c **** 	return LEF_QueueClear(&StdQueue);
 122:src/LEF/LEF_Queue.c **** }
 123:src/LEF/LEF_Queue.c **** 
 124:src/LEF/LEF_Queue.c **** uint16_t LEF_QueueStdCnt(void) {
 610               		.loc 1 124 0
 611               		.cfi_startproc
 612               	/* prologue: function */
 613               	/* frame size = 0 */
 614               	/* stack size = 0 */
 615               	.L__stack_usage = 0
 616               	.LVL56:
 617               	.LBB89:
 618               	.LBB90:
 108:src/LEF/LEF_Queue.c **** }
 619               		.loc 1 108 0
 620 0178 8091 0000 		lds r24,StdQueue+21
 621               	.LVL57:
 622               	.LBE90:
 623               	.LBE89:
 125:src/LEF/LEF_Queue.c ****   return LEF_QueueCnt(&StdQueue);
 126:src/LEF/LEF_Queue.c **** }
 624               		.loc 1 126 0
 625 017c 90E0      		ldi r25,0
 626 017e 0895      		ret
 627               		.cfi_endproc
 628               	.LFE17:
 630               		.comm	StdQueue,22,1
 631               	.Letext0:
 632               		.file 3 "/usr/lib/avr/include/stdint.h"
 633               		.file 4 "src/LEF/LEF_Queue.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 LEF_Queue.c
     /tmp/cckcFtwU.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cckcFtwU.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cckcFtwU.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cckcFtwU.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cckcFtwU.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cckcFtwU.s:11     .text:0000000000000000 LEF_QueueSend.part.1
     /tmp/cckcFtwU.s:116    .text:0000000000000040 LEF_QueueClear
     /tmp/cckcFtwU.s:132    .text:0000000000000048 LEF_element_cpy
     /tmp/cckcFtwU.s:157    .text:000000000000005a LEF_QueueInit
     /tmp/cckcFtwU.s:182    .text:0000000000000062 queue_ptr_inc
     /tmp/cckcFtwU.s:211    .text:000000000000007a LEF_QueueSend
     /tmp/cckcFtwU.s:247    .text:000000000000008a LEF_QueueWait
     /tmp/cckcFtwU.s:348    .text:00000000000000d6 LEF_QueueSendEvent
     /tmp/cckcFtwU.s:416    .text:0000000000000100 LEF_QueueCnt
     /tmp/cckcFtwU.s:437    .text:0000000000000108 LEF_QueueStdSend
                            *COM*:0000000000000016 StdQueue
     /tmp/cckcFtwU.s:481    .text:000000000000011e LEF_QueueStdWait
     /tmp/cckcFtwU.s:582    .text:000000000000016e LEF_QueueStdClear
     /tmp/cckcFtwU.s:608    .text:0000000000000178 LEF_QueueStdCnt

UNDEFINED SYMBOLS
__divmodhi4
__do_clear_bss
