   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	__vector_11
  12               	__vector_11:
  13               	.LFB19:
  14               		.file 1 "src/main.c"
   1:src/main.c    **** /**
   2:src/main.c    ****  *---------------------------------------------------------------------------
   3:src/main.c    ****  * @brief    A simple LEF test
   4:src/main.c    ****  *
   5:src/main.c    ****  * @file     main.c
   6:src/main.c    ****  * @author   Peter Malmberg <peter.malmberg@gmail.com>
   7:src/main.c    ****  * @version  0.01
   8:src/main.c    ****  * @date     2023-03-31
   9:src/main.c    ****  * @license  MIT
  10:src/main.c    ****  *
  11:src/main.c    ****  *---------------------------------------------------------------------------
  12:src/main.c    ****  *
  13:src/main.c    ****  *
  14:src/main.c    ****  */
  15:src/main.c    **** 
  16:src/main.c    **** #include <avr/io.h>
  17:src/main.c    **** #include <avr/pgmspace.h>
  18:src/main.c    **** #include <avr/interrupt.h>
  19:src/main.c    **** #include <avr/wdt.h>
  20:src/main.c    **** #include <avr/sleep.h>
  21:src/main.c    **** #include <util/delay.h>
  22:src/main.c    **** #include <util/atomic.h>
  23:src/main.c    **** #include <stdio.h>
  24:src/main.c    **** #include <stdlib.h>
  25:src/main.c    **** 
  26:src/main.c    **** #include "main.h"
  27:src/main.c    **** #include "uart.h"
  28:src/main.c    **** #include "def.h"
  29:src/main.c    **** #include "LEF.h"
  30:src/main.c    **** #include "LEF_Timer.h"
  31:src/main.c    **** 
  32:src/main.c    **** 
  33:src/main.c    **** #define UART_BAUD_RATE 57600
  34:src/main.c    **** 
  35:src/main.c    **** 
  36:src/main.c    **** void hw_init(void);
  37:src/main.c    **** 
  38:src/main.c    **** LEF_Timer  timer1;
  39:src/main.c    **** LEF_Timer  timer2;
  40:src/main.c    **** LEF_Led    led;
  41:src/main.c    **** LEF_Button button;
  42:src/main.c    **** 
  43:src/main.c    **** static FILE mystdout = FDEV_SETUP_STREAM((void*)uart_putc, NULL, _FDEV_SETUP_WRITE);
  44:src/main.c    **** 
  45:src/main.c    **** uint32_t volatile x = 0;
  46:src/main.c    **** uint32_t volatile y = 0;
  47:src/main.c    **** 
  48:src/main.c    **** 
  49:src/main.c    **** ISR(TIMER1_COMPA_vect) {
  15               		.loc 1 49 0
  16               		.cfi_startproc
  17 0000 1F92      		push r1
  18               	.LCFI0:
  19               		.cfi_def_cfa_offset 3
  20               		.cfi_offset 1, -2
  21 0002 0F92      		push r0
  22               	.LCFI1:
  23               		.cfi_def_cfa_offset 4
  24               		.cfi_offset 0, -3
  25 0004 0FB6      		in r0,__SREG__
  26 0006 0F92      		push r0
  27 0008 1124      		clr __zero_reg__
  28 000a 2F93      		push r18
  29               	.LCFI2:
  30               		.cfi_def_cfa_offset 5
  31               		.cfi_offset 18, -4
  32 000c 3F93      		push r19
  33               	.LCFI3:
  34               		.cfi_def_cfa_offset 6
  35               		.cfi_offset 19, -5
  36 000e 4F93      		push r20
  37               	.LCFI4:
  38               		.cfi_def_cfa_offset 7
  39               		.cfi_offset 20, -6
  40 0010 5F93      		push r21
  41               	.LCFI5:
  42               		.cfi_def_cfa_offset 8
  43               		.cfi_offset 21, -7
  44 0012 6F93      		push r22
  45               	.LCFI6:
  46               		.cfi_def_cfa_offset 9
  47               		.cfi_offset 22, -8
  48 0014 7F93      		push r23
  49               	.LCFI7:
  50               		.cfi_def_cfa_offset 10
  51               		.cfi_offset 23, -9
  52 0016 8F93      		push r24
  53               	.LCFI8:
  54               		.cfi_def_cfa_offset 11
  55               		.cfi_offset 24, -10
  56 0018 9F93      		push r25
  57               	.LCFI9:
  58               		.cfi_def_cfa_offset 12
  59               		.cfi_offset 25, -11
  60 001a AF93      		push r26
  61               	.LCFI10:
  62               		.cfi_def_cfa_offset 13
  63               		.cfi_offset 26, -12
  64 001c BF93      		push r27
  65               	.LCFI11:
  66               		.cfi_def_cfa_offset 14
  67               		.cfi_offset 27, -13
  68 001e EF93      		push r30
  69               	.LCFI12:
  70               		.cfi_def_cfa_offset 15
  71               		.cfi_offset 30, -14
  72 0020 FF93      		push r31
  73               	.LCFI13:
  74               		.cfi_def_cfa_offset 16
  75               		.cfi_offset 31, -15
  76               	/* prologue: Signal */
  77               	/* frame size = 0 */
  78               	/* stack size = 15 */
  79               	.L__stack_usage = 15
  50:src/main.c    ****   TIMER1_RELOAD(0);
  80               		.loc 1 50 0
  81 0022 1092 8500 		sts 133,__zero_reg__
  82 0026 1092 8400 		sts 132,__zero_reg__
  51:src/main.c    **** 	x++;
  83               		.loc 1 51 0
  84 002a 8091 0000 		lds r24,x
  85 002e 9091 0000 		lds r25,x+1
  86 0032 A091 0000 		lds r26,x+2
  87 0036 B091 0000 		lds r27,x+3
  88 003a 0196      		adiw r24,1
  89 003c A11D      		adc r26,__zero_reg__
  90 003e B11D      		adc r27,__zero_reg__
  91 0040 8093 0000 		sts x,r24
  92 0044 9093 0000 		sts x+1,r25
  93 0048 A093 0000 		sts x+2,r26
  94 004c B093 0000 		sts x+3,r27
  52:src/main.c    **** 
  53:src/main.c    **** 	LEF_TimerUpdate(&timer1);
  95               		.loc 1 53 0
  96 0050 80E0      		ldi r24,lo8(timer1)
  97 0052 90E0      		ldi r25,hi8(timer1)
  98 0054 0E94 0000 		call LEF_TimerUpdate
  99               	.LVL0:
  54:src/main.c    **** 	LEF_TimerUpdate(&timer2);
 100               		.loc 1 54 0
 101 0058 80E0      		ldi r24,lo8(timer2)
 102 005a 90E0      		ldi r25,hi8(timer2)
 103 005c 0E94 0000 		call LEF_TimerUpdate
 104               	.LVL1:
  55:src/main.c    **** 	
  56:src/main.c    **** 	if (LEF_LedUpdate(&led)) {
 105               		.loc 1 56 0
 106 0060 80E0      		ldi r24,lo8(led)
 107 0062 90E0      		ldi r25,hi8(led)
 108 0064 0E94 0000 		call LEF_LedUpdate
 109               	.LVL2:
 110 0068 8111      		cpse r24,__zero_reg__
 111 006a 00C0      		rjmp .L5
  57:src/main.c    **** 		ARDUINO_LED_ON();
  58:src/main.c    **** 	} else {
  59:src/main.c    **** 		ARDUINO_LED_OFF();
 112               		.loc 1 59 0
 113 006c 2D98      		cbi 0x5,5
 114               	.L3:
  60:src/main.c    **** 	}
  61:src/main.c    **** 
  62:src/main.c    **** 	LEF_Button_update(&button, (PIND & (1<<PIN7))==0  );
 115               		.loc 1 62 0
 116 006e 69B1      		in r22,0x9
 117 0070 6095      		com r22
 118 0072 661F      		rol r22
 119 0074 6627      		clr r22
 120 0076 661F      		rol r22
 121 0078 80E0      		ldi r24,lo8(button)
 122 007a 90E0      		ldi r25,hi8(button)
 123 007c 0E94 0000 		call LEF_Button_update
 124               	.LVL3:
 125               	/* epilogue start */
  63:src/main.c    **** }
 126               		.loc 1 63 0
 127 0080 FF91      		pop r31
 128 0082 EF91      		pop r30
 129 0084 BF91      		pop r27
 130 0086 AF91      		pop r26
 131 0088 9F91      		pop r25
 132 008a 8F91      		pop r24
 133 008c 7F91      		pop r23
 134 008e 6F91      		pop r22
 135 0090 5F91      		pop r21
 136 0092 4F91      		pop r20
 137 0094 3F91      		pop r19
 138 0096 2F91      		pop r18
 139 0098 0F90      		pop r0
 140 009a 0FBE      		out __SREG__,r0
 141 009c 0F90      		pop r0
 142 009e 1F90      		pop r1
 143 00a0 1895      		reti
 144               	.L5:
  57:src/main.c    **** 		ARDUINO_LED_ON();
 145               		.loc 1 57 0
 146 00a2 2D9A      		sbi 0x5,5
 147 00a4 00C0      		rjmp .L3
 148               		.cfi_endproc
 149               	.LFE19:
 151               	.global	hw_init
 153               	hw_init:
 154               	.LFB20:
  64:src/main.c    **** 
  65:src/main.c    **** 
  66:src/main.c    **** //ISR(TIMER2_COMPA_vect) {
  67:src/main.c    **** 	//static int cnt;
  68:src/main.c    **** 	//static LEF_queue_element qe;
  69:src/main.c    **** 	//timer2_ticks++;
  70:src/main.c    **** 	
  71:src/main.c    **** //	LEF_TimerUpdate(&timer1, 1);
  72:src/main.c    **** 
  73:src/main.c    **** //}
  74:src/main.c    **** 
  75:src/main.c    **** 
  76:src/main.c    **** void hw_init(void) {
 155               		.loc 1 76 0
 156               		.cfi_startproc
 157               	/* prologue: function */
 158               	/* frame size = 0 */
 159               	/* stack size = 0 */
 160               	.L__stack_usage = 0
  77:src/main.c    **** 	stdout = &mystdout;
 161               		.loc 1 77 0
 162 00a6 80E0      		ldi r24,lo8(mystdout)
 163 00a8 90E0      		ldi r25,hi8(mystdout)
 164 00aa 9093 0000 		sts __iob+2+1,r25
 165 00ae 8093 0000 		sts __iob+2,r24
  78:src/main.c    **** 	uart_init(UART_BAUD_SELECT(UART_BAUD_RATE, F_CPU));
 166               		.loc 1 78 0
 167 00b2 80E1      		ldi r24,lo8(16)
 168 00b4 90E0      		ldi r25,0
 169 00b6 0E94 0000 		call uart_init
 170               	.LVL4:
  79:src/main.c    **** 
  80:src/main.c    **** 	ARDUINO_LED_INIT();
 171               		.loc 1 80 0
 172 00ba 259A      		sbi 0x4,5
  81:src/main.c    **** 	
  82:src/main.c    **** 	// Timer 1 (16 bit)
  83:src/main.c    **** 	TIMER1_CLK_PRES_256(); // set prescaler to 1/1024
 173               		.loc 1 83 0
 174 00bc E1E8      		ldi r30,lo8(-127)
 175 00be F0E0      		ldi r31,0
 176 00c0 8081      		ld r24,Z
 177 00c2 8460      		ori r24,lo8(4)
 178 00c4 8083      		st Z,r24
  84:src/main.c    **** 	TIMER1_OCA_SET(625);
 179               		.loc 1 84 0
 180 00c6 82E0      		ldi r24,lo8(2)
 181 00c8 8093 8900 		sts 137,r24
 182 00cc 81E7      		ldi r24,lo8(113)
 183 00ce 8093 8800 		sts 136,r24
  85:src/main.c    **** 	TIMER1_OCA_IE();        // enable output compare A interrupt
 184               		.loc 1 85 0
 185 00d2 EFE6      		ldi r30,lo8(111)
 186 00d4 F0E0      		ldi r31,0
 187 00d6 8081      		ld r24,Z
 188 00d8 8260      		ori r24,lo8(2)
 189 00da 8083      		st Z,r24
  86:src/main.c    **** 	
  87:src/main.c    **** 	//set_sleep_mode(SLEEP_MODE_IDLE);
  88:src/main.c    **** 	//sleep_enable();
  89:src/main.c    **** 
  90:src/main.c    **** 	// Activate pullup 
  91:src/main.c    **** 	PIND = 0x01 << PIN7;
 190               		.loc 1 91 0
 191 00dc 80E8      		ldi r24,lo8(-128)
 192 00de 89B9      		out 0x9,r24
  92:src/main.c    **** 	
  93:src/main.c    **** 	sei();
 193               		.loc 1 93 0
 194               	/* #APP */
 195               	 ;  93 "src/main.c" 1
 196 00e0 7894      		sei
 197               	 ;  0 "" 2
 198               	/* #NOAPP */
 199 00e2 0895      		ret
 200               		.cfi_endproc
 201               	.LFE20:
 203               		.section	.rodata.str1.1,"aMS",@progbits,1
 204               	.LC0:
 205 0000 0A0A 5374 		.string	"\n\nStarting LEF simple test"
 205      6172 7469 
 205      6E67 204C 
 205      4546 2073 
 205      696D 706C 
 206               	.LC1:
 207 001b 4576 656E 		.string	"Event id: %3d   func: %3d   PIND: %x\n"
 207      7420 6964 
 207      3A20 2533 
 207      6420 2020 
 207      6675 6E63 
 208               		.section	.text.startup,"ax",@progbits
 209               	.global	main
 211               	main:
 212               	.LFB21:
  94:src/main.c    **** }
  95:src/main.c    **** 
  96:src/main.c    **** 
  97:src/main.c    **** int main() {
 213               		.loc 1 97 0
 214               		.cfi_startproc
 215 0000 CF93      		push r28
 216               	.LCFI14:
 217               		.cfi_def_cfa_offset 3
 218               		.cfi_offset 28, -2
 219 0002 DF93      		push r29
 220               	.LCFI15:
 221               		.cfi_def_cfa_offset 4
 222               		.cfi_offset 29, -3
 223 0004 00D0      		rcall .
 224               	.LCFI16:
 225               		.cfi_def_cfa_offset 6
 226 0006 CDB7      		in r28,__SP_L__
 227 0008 DEB7      		in r29,__SP_H__
 228               	.LCFI17:
 229               		.cfi_def_cfa_register 28
 230               	/* prologue: function */
 231               	/* frame size = 2 */
 232               	/* stack size = 4 */
 233               	.L__stack_usage = 4
  98:src/main.c    **** 	LEF_queue_element dst;
  99:src/main.c    **** //	uint8_t i;
 100:src/main.c    **** 	 
 101:src/main.c    **** 	LEF_Init();
 234               		.loc 1 101 0
 235 000a 0E94 0000 		call LEF_Init
 236               	.LVL5:
 102:src/main.c    **** 	LEF_TimerInit(&timer1, 1);
 237               		.loc 1 102 0
 238 000e 61E0      		ldi r22,lo8(1)
 239 0010 80E0      		ldi r24,lo8(timer1)
 240 0012 90E0      		ldi r25,hi8(timer1)
 241 0014 0E94 0000 		call LEF_TimerInit
 242               	.LVL6:
 103:src/main.c    **** 	LEF_TimerStartRepeat(&timer1, 100);
 243               		.loc 1 103 0
 244 0018 64E6      		ldi r22,lo8(100)
 245 001a 70E0      		ldi r23,0
 246 001c 80E0      		ldi r24,lo8(timer1)
 247 001e 90E0      		ldi r25,hi8(timer1)
 248 0020 0E94 0000 		call LEF_TimerStartRepeat
 249               	.LVL7:
 104:src/main.c    **** 	LEF_TimerInit(&timer2, 2);
 250               		.loc 1 104 0
 251 0024 62E0      		ldi r22,lo8(2)
 252 0026 80E0      		ldi r24,lo8(timer2)
 253 0028 90E0      		ldi r25,hi8(timer2)
 254 002a 0E94 0000 		call LEF_TimerInit
 255               	.LVL8:
 105:src/main.c    **** 	LEF_TimerStartRepeat(&timer2, 400);
 256               		.loc 1 105 0
 257 002e 60E9      		ldi r22,lo8(-112)
 258 0030 71E0      		ldi r23,lo8(1)
 259 0032 80E0      		ldi r24,lo8(timer2)
 260 0034 90E0      		ldi r25,hi8(timer2)
 261 0036 0E94 0000 		call LEF_TimerStartRepeat
 262               	.LVL9:
 106:src/main.c    **** 	
 107:src/main.c    **** 	LEF_LedInit(&led);
 263               		.loc 1 107 0
 264 003a 80E0      		ldi r24,lo8(led)
 265 003c 90E0      		ldi r25,hi8(led)
 266 003e 0E94 0000 		call LEF_LedInit
 267               	.LVL10:
 108:src/main.c    **** 	LEF_LedSetState(&led, LED_STATE_FAST_BLINK);
 268               		.loc 1 108 0
 269 0042 63E0      		ldi r22,lo8(3)
 270 0044 70E0      		ldi r23,0
 271 0046 80E0      		ldi r24,lo8(led)
 272 0048 90E0      		ldi r25,hi8(led)
 273 004a 0E94 0000 		call LEF_LedSetState
 274               	.LVL11:
 109:src/main.c    **** 	
 110:src/main.c    **** 	LEF_Button_init(&button, 10);
 275               		.loc 1 110 0
 276 004e 6AE0      		ldi r22,lo8(10)
 277 0050 80E0      		ldi r24,lo8(button)
 278 0052 90E0      		ldi r25,hi8(button)
 279 0054 0E94 0000 		call LEF_Button_init
 280               	.LVL12:
 111:src/main.c    **** 
 112:src/main.c    **** 	hw_init();
 281               		.loc 1 112 0
 282 0058 0E94 0000 		call hw_init
 283               	.LVL13:
 284               	.LBB4:
 285               	.LBB5:
 286               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 287               		.loc 2 187 0
 288 005c 2FEF      		ldi r18,lo8(3199999)
 289 005e 83ED      		ldi r24,hi8(3199999)
 290 0060 90E3      		ldi r25,hlo8(3199999)
 291 0062 2150      	1:	subi r18,1
 292 0064 8040      		sbci r24,0
 293 0066 9040      		sbci r25,0
 294 0068 01F4      		brne 1b
 295 006a 00C0      		rjmp .
 296 006c 0000      		nop
 297               	.LVL14:
 298               	.LBE5:
 299               	.LBE4:
 113:src/main.c    **** 	_delay_ms(1000);
 114:src/main.c    **** 	printf("\n\nStarting LEF simple test\n");
 300               		.loc 1 114 0
 301 006e 80E0      		ldi r24,lo8(.LC0)
 302 0070 90E0      		ldi r25,hi8(.LC0)
 303 0072 0E94 0000 		call puts
 304               	.LVL15:
 115:src/main.c    **** 
 116:src/main.c    **** 	while(1) {
 117:src/main.c    **** 
 118:src/main.c    **** //	    DEBUGPRINT("LEF Cli test\n");
 119:src/main.c    **** //	    char *str = "test\n";
 120:src/main.c    **** //	    LEF_CliPutChar('\n');
 121:src/main.c    **** 
 122:src/main.c    **** 		LEF_QueueWait(&StdQueue, &dst);
 123:src/main.c    **** 		printf("Event id: %3d   func: %3d   PIND: %x\n", dst.id, dst.func, PIND);
 305               		.loc 1 123 0
 306 0076 00E0      		ldi r16,lo8(.LC1)
 307 0078 10E0      		ldi r17,hi8(.LC1)
 308               	.L8:
 122:src/main.c    **** 		printf("Event id: %3d   func: %3d   PIND: %x\n", dst.id, dst.func, PIND);
 309               		.loc 1 122 0 discriminator 1
 310 007a BE01      		movw r22,r28
 311 007c 6F5F      		subi r22,-1
 312 007e 7F4F      		sbci r23,-1
 313 0080 80E0      		ldi r24,lo8(StdQueue)
 314 0082 90E0      		ldi r25,hi8(StdQueue)
 315 0084 0E94 0000 		call LEF_QueueWait
 316               	.LVL16:
 317               		.loc 1 123 0 discriminator 1
 318 0088 89B1      		in r24,0x9
 319 008a 1F92      		push __zero_reg__
 320 008c 8F93      		push r24
 321 008e 8A81      		ldd r24,Y+2
 322 0090 1F92      		push __zero_reg__
 323 0092 8F93      		push r24
 324 0094 8981      		ldd r24,Y+1
 325 0096 1F92      		push __zero_reg__
 326 0098 8F93      		push r24
 327 009a 1F93      		push r17
 328 009c 0F93      		push r16
 329 009e 0E94 0000 		call printf
 330               	.LVL17:
 331 00a2 0FB6      		in __tmp_reg__,__SREG__
 332 00a4 F894      		cli
 333 00a6 DEBF      		out __SP_H__,r29
 334 00a8 0FBE      		out __SREG__,__tmp_reg__
 335 00aa CDBF      		out __SP_L__,r28
 336 00ac 00C0      		rjmp .L8
 337               		.cfi_endproc
 338               	.LFE21:
 340               	.global	y
 341               		.section .bss
 344               	y:
 345 0000 0000 0000 		.zero	4
 346               	.global	x
 349               	x:
 350 0004 0000 0000 		.zero	4
 351               		.data
 354               	mystdout:
 355 0000 0000 00   		.zero	3
 356 0003 02        		.byte	2
 357 0004 0000 0000 		.zero	4
 358 0008 0000      		.word	gs(uart_putc)
 359 000a 0000      		.word	0
 360 000c 0000      		.word	0
 361               		.comm	button,3,1
 362               		.comm	led,2,1
 363               		.comm	timer2,5,1
 364               		.comm	timer1,5,1
 365               		.text
 366               	.Letext0:
 367               		.file 3 "/usr/lib/avr/include/stdint.h"
 368               		.file 4 "/usr/lib/avr/include/stdio.h"
 369               		.file 5 "src/LEF/LEF_Queue.h"
 370               		.file 6 "src/LEF/LEF_Timer.h"
 371               		.file 7 "src/LEF/LEF_Led.h"
 372               		.file 8 "src/LEF/LEF_Button.h"
 373               		.file 9 "src/uart.h"
 374               		.file 10 "src/LEF/LEF.h"
 375               		.file 11 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/cccGoMQc.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cccGoMQc.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cccGoMQc.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cccGoMQc.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cccGoMQc.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cccGoMQc.s:12     .text:0000000000000000 __vector_11
     /tmp/cccGoMQc.s:349    .bss:0000000000000004 x
                            *COM*:0000000000000005 timer1
                            *COM*:0000000000000005 timer2
                            *COM*:0000000000000002 led
                            *COM*:0000000000000003 button
     /tmp/cccGoMQc.s:153    .text:00000000000000a6 hw_init
     /tmp/cccGoMQc.s:354    .data:0000000000000000 mystdout
     /tmp/cccGoMQc.s:211    .text.startup:0000000000000000 main
     /tmp/cccGoMQc.s:344    .bss:0000000000000000 y

UNDEFINED SYMBOLS
LEF_TimerUpdate
LEF_LedUpdate
LEF_Button_update
__iob
uart_init
LEF_Init
LEF_TimerInit
LEF_TimerStartRepeat
LEF_LedInit
LEF_LedSetState
LEF_Button_init
puts
StdQueue
LEF_QueueWait
printf
uart_putc
__do_copy_data
__do_clear_bss
