   1               		.file	"uart.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	__vector_18
  12               	__vector_18:
  13               	.LFB1:
  14               		.file 1 "src/uart.c"
   1:src/uart.c    **** /*************************************************************************
   2:src/uart.c    **** Title:    Interrupt UART library with receive/transmit circular buffers
   3:src/uart.c    **** Author:   Peter Fleury <pfleury@gmx.ch>   http://tinyurl.com/peterfleury
   4:src/uart.c    **** File:     $Id: uart.c,v 1.15.2.4 2015/09/05 18:33:32 peter Exp $
   5:src/uart.c    **** Software: AVR-GCC 4.x
   6:src/uart.c    **** Hardware: any AVR with built-in UART, 
   7:src/uart.c    **** License:  GNU General Public License 
   8:src/uart.c    ****           
   9:src/uart.c    **** DESCRIPTION:
  10:src/uart.c    ****     An interrupt is generated when the UART has finished transmitting or
  11:src/uart.c    ****     receiving a byte. The interrupt handling routines use circular buffers
  12:src/uart.c    ****     for buffering received and transmitted data.
  13:src/uart.c    ****     
  14:src/uart.c    ****     The UART_RX_BUFFER_SIZE and UART_TX_BUFFER_SIZE variables define
  15:src/uart.c    ****     the buffer size in bytes. Note that these variables must be a 
  16:src/uart.c    ****     power of 2.
  17:src/uart.c    ****     
  18:src/uart.c    **** USAGE:
  19:src/uart.c    ****     Refere to the header file uart.h for a description of the routines. 
  20:src/uart.c    ****     See also example test_uart.c.
  21:src/uart.c    **** 
  22:src/uart.c    **** NOTES:
  23:src/uart.c    ****     Based on Atmel Application Note AVR306
  24:src/uart.c    ****                     
  25:src/uart.c    **** LICENSE:
  26:src/uart.c    ****     Copyright (C) 2015 Peter Fleury, GNU General Public License Version 3
  27:src/uart.c    **** 
  28:src/uart.c    ****     This program is free software; you can redistribute it and/or modify
  29:src/uart.c    ****     it under the terms of the GNU General Public License as published by
  30:src/uart.c    ****     the Free Software Foundation; either version 2 of the License, or
  31:src/uart.c    ****     any later version.
  32:src/uart.c    **** 
  33:src/uart.c    ****     This program is distributed in the hope that it will be useful,
  34:src/uart.c    ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  35:src/uart.c    ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  36:src/uart.c    ****     GNU General Public License for more details.
  37:src/uart.c    ****                         
  38:src/uart.c    **** *************************************************************************/
  39:src/uart.c    **** #include <avr/io.h>
  40:src/uart.c    **** #include <avr/interrupt.h>
  41:src/uart.c    **** #include <avr/pgmspace.h>
  42:src/uart.c    **** #include "uart.h"
  43:src/uart.c    **** 
  44:src/uart.c    **** 
  45:src/uart.c    **** /*
  46:src/uart.c    ****  *  constants and macros
  47:src/uart.c    ****  */
  48:src/uart.c    **** 
  49:src/uart.c    **** /* size of RX/TX buffers */
  50:src/uart.c    **** #define UART_RX_BUFFER_MASK ( UART_RX_BUFFER_SIZE - 1)
  51:src/uart.c    **** #define UART_TX_BUFFER_MASK ( UART_TX_BUFFER_SIZE - 1)
  52:src/uart.c    **** 
  53:src/uart.c    **** #if ( UART_RX_BUFFER_SIZE & UART_RX_BUFFER_MASK )
  54:src/uart.c    **** #error RX buffer size is not a power of 2
  55:src/uart.c    **** #endif
  56:src/uart.c    **** #if ( UART_TX_BUFFER_SIZE & UART_TX_BUFFER_MASK )
  57:src/uart.c    **** #error TX buffer size is not a power of 2
  58:src/uart.c    **** #endif
  59:src/uart.c    **** 
  60:src/uart.c    **** 
  61:src/uart.c    **** #if defined(__AVR_AT90S2313__) || defined(__AVR_AT90S4414__) || defined(__AVR_AT90S8515__) || \
  62:src/uart.c    ****     defined(__AVR_AT90S4434__) || defined(__AVR_AT90S8535__) || \
  63:src/uart.c    ****     defined(__AVR_ATmega103__)
  64:src/uart.c    ****  /* old AVR classic or ATmega103 with one UART */
  65:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   UART_RX_vect 
  66:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  UART_UDRE_vect
  67:src/uart.c    ****  #define UART0_STATUS      USR
  68:src/uart.c    ****  #define UART0_CONTROL     UCR
  69:src/uart.c    ****  #define UART0_DATA        UDR  
  70:src/uart.c    ****  #define UART0_UDRIE       UDRIE
  71:src/uart.c    ****  #define UART0_UBRRL       UBRR
  72:src/uart.c    ****  #define UART0_BIT_U2X     U2X
  73:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE
  74:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN
  75:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN
  76:src/uart.c    **** #elif defined(__AVR_AT90S2333__) || defined(__AVR_AT90S4433__)
  77:src/uart.c    ****  /* old AVR classic with one UART */
  78:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   UART_RX_vect 
  79:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  UART_UDRE_vect
  80:src/uart.c    ****  #define UART0_STATUS      UCSRA
  81:src/uart.c    ****  #define UART0_CONTROL     UCSRB
  82:src/uart.c    ****  #define UART0_DATA        UDR 
  83:src/uart.c    ****  #define UART0_UDRIE       UDRIE
  84:src/uart.c    ****  #define UART0_UBRRL       UBRR
  85:src/uart.c    ****  #define UART0_BIT_U2X     U2X
  86:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE
  87:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN
  88:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN
  89:src/uart.c    **** #elif defined(__AVR_AT90PWM216__) || defined(__AVR_AT90PWM316__) 
  90:src/uart.c    ****  /* AT90PWN216/316 with one USART */
  91:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART_RX_vect
  92:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
  93:src/uart.c    ****  #define UART0_STATUS      UCSRA
  94:src/uart.c    ****  #define UART0_CONTROL     UCSRB
  95:src/uart.c    ****  #define UART0_CONTROLC    UCSRC
  96:src/uart.c    ****  #define UART0_DATA        UDR
  97:src/uart.c    ****  #define UART0_UDRIE       UDRIE
  98:src/uart.c    ****  #define UART0_UBRRL       UBRRL
  99:src/uart.c    ****  #define UART0_UBRRH       UBRRH
 100:src/uart.c    ****  #define UART0_BIT_U2X     U2X
 101:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE
 102:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN
 103:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN
 104:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ0
 105:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ1 
 106:src/uart.c    **** #elif defined(__AVR_ATmega8__) || defined(__AVR_ATmega8A__) || \
 107:src/uart.c    ****       defined(__AVR_ATmega16__) || defined(__AVR_ATmega16A__) || \
 108:src/uart.c    ****       defined(__AVR_ATmega32__) || defined(__AVR_ATmega32A__) || \
 109:src/uart.c    ****       defined(__AVR_ATmega323__)
 110:src/uart.c    ****  /* ATmega with one USART */
 111:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART_RXC_vect
 112:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 113:src/uart.c    ****  #define UART0_STATUS      UCSRA
 114:src/uart.c    ****  #define UART0_CONTROL     UCSRB
 115:src/uart.c    ****  #define UART0_CONTROLC    UCSRC
 116:src/uart.c    ****  #define UART0_DATA        UDR
 117:src/uart.c    ****  #define UART0_UDRIE       UDRIE
 118:src/uart.c    ****  #define UART0_UBRRL       UBRRL
 119:src/uart.c    ****  #define UART0_UBRRH       UBRRH
 120:src/uart.c    ****  #define UART0_BIT_U2X     U2X
 121:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE
 122:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN
 123:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN
 124:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ0
 125:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ1
 126:src/uart.c    ****  #define UART0_BIT_URSEL   URSEL
 127:src/uart.c    **** #elif defined (__AVR_ATmega8515__) || defined(__AVR_ATmega8535__)
 128:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART_RX_vect
 129:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 130:src/uart.c    ****  #define UART0_STATUS      UCSRA
 131:src/uart.c    ****  #define UART0_CONTROL     UCSRB
 132:src/uart.c    ****  #define UART0_CONTROLC    UCSRC 
 133:src/uart.c    ****  #define UART0_DATA        UDR
 134:src/uart.c    ****  #define UART0_UDRIE       UDRIE
 135:src/uart.c    ****  #define UART0_UBRRL       UBRRL
 136:src/uart.c    ****  #define UART0_UBRRH       UBRRH
 137:src/uart.c    ****  #define UART0_BIT_U2X     U2X
 138:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE
 139:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN
 140:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN
 141:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ0
 142:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ1
 143:src/uart.c    ****  #define UART0_BIT_URSEL   URSEL
 144:src/uart.c    **** #elif defined(__AVR_ATmega163__)
 145:src/uart.c    ****   /* ATmega163 with one UART */
 146:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   UART_RX_vect
 147:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  UART_UDRE_vect
 148:src/uart.c    ****  #define UART0_STATUS      UCSRA
 149:src/uart.c    ****  #define UART0_CONTROL     UCSRB
 150:src/uart.c    ****  #define UART0_DATA        UDR
 151:src/uart.c    ****  #define UART0_UDRIE       UDRIE
 152:src/uart.c    ****  #define UART0_UBRRL       UBRR
 153:src/uart.c    ****  #define UART0_UBRRH       UBRRHI
 154:src/uart.c    ****  #define UART0_BIT_U2X     U2X
 155:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE
 156:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN
 157:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN
 158:src/uart.c    **** #elif defined(__AVR_ATmega162__) 
 159:src/uart.c    ****  /* ATmega with two USART */
 160:src/uart.c    ****  #define ATMEGA_USART1
 161:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART0_RXC_vect
 162:src/uart.c    ****  #define UART1_RECEIVE_INTERRUPT   USART1_RXC_vect
 163:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 164:src/uart.c    ****  #define UART1_TRANSMIT_INTERRUPT  USART1_UDRE_vect
 165:src/uart.c    ****  #define UART0_STATUS      UCSR0A
 166:src/uart.c    ****  #define UART0_CONTROL     UCSR0B
 167:src/uart.c    ****  #define UART0_CONTROLC    UCSR0C
 168:src/uart.c    ****  #define UART0_DATA        UDR0
 169:src/uart.c    ****  #define UART0_UDRIE       UDRIE0
 170:src/uart.c    ****  #define UART0_UBRRL       UBRR0L
 171:src/uart.c    ****  #define UART0_UBRRH       UBRR0H
 172:src/uart.c    ****  #define UART0_BIT_URSEL   URSEL0
 173:src/uart.c    ****  #define UART0_BIT_U2X     U2X0
 174:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE0
 175:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN0
 176:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN0
 177:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ00
 178:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ01
 179:src/uart.c    ****  #define UART1_STATUS      UCSR1A
 180:src/uart.c    ****  #define UART1_CONTROL     UCSR1B
 181:src/uart.c    ****  #define UART1_CONTROLC    UCSR1C
 182:src/uart.c    ****  #define UART1_DATA        UDR1
 183:src/uart.c    ****  #define UART1_UDRIE       UDRIE1
 184:src/uart.c    ****  #define UART1_UBRRL       UBRR1L
 185:src/uart.c    ****  #define UART1_UBRRH       UBRR1H
 186:src/uart.c    ****  #define UART1_BIT_URSEL   URSEL1
 187:src/uart.c    ****  #define UART1_BIT_U2X     U2X1
 188:src/uart.c    ****  #define UART1_BIT_RXCIE   RXCIE1
 189:src/uart.c    ****  #define UART1_BIT_RXEN    RXEN1
 190:src/uart.c    ****  #define UART1_BIT_TXEN    TXEN1
 191:src/uart.c    ****  #define UART1_BIT_UCSZ0   UCSZ10
 192:src/uart.c    ****  #define UART1_BIT_UCSZ1   UCSZ11 
 193:src/uart.c    **** #elif defined(__AVR_ATmega161__)
 194:src/uart.c    ****  /* ATmega with UART */
 195:src/uart.c    ****  #error "AVR ATmega161 currently not supported by this libaray !"
 196:src/uart.c    **** #elif defined(__AVR_ATmega169__)
 197:src/uart.c    ****  /* ATmega with one USART */
 198:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 199:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 200:src/uart.c    ****  #define UART0_STATUS      UCSRA
 201:src/uart.c    ****  #define UART0_CONTROL     UCSRB
 202:src/uart.c    ****  #define UART0_CONTROLC    UCSRC
 203:src/uart.c    ****  #define UART0_DATA        UDR
 204:src/uart.c    ****  #define UART0_UDRIE       UDRIE
 205:src/uart.c    ****  #define UART0_UBRRL       UBRRL
 206:src/uart.c    ****  #define UART0_UBRRH       UBRRH
 207:src/uart.c    ****  #define UART0_BIT_U2X     U2X
 208:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE
 209:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN
 210:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN
 211:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ0
 212:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ1
 213:src/uart.c    **** #elif defined(__AVR_ATmega48__) || defined(__AVR_ATmega48A__) || defined(__AVR_ATmega48P__) || defi
 214:src/uart.c    ****       defined(__AVR_ATmega88__) || defined(__AVR_ATmega88A__) || defined(__AVR_ATmega88P__) || defi
 215:src/uart.c    ****       defined(__AVR_ATmega168__) || defined(__AVR_ATmega168A__)|| defined(__AVR_ATmega168P__)|| def
 216:src/uart.c    ****       defined(__AVR_ATmega328__) || defined(__AVR_ATmega328P__) || \
 217:src/uart.c    ****       defined(__AVR_ATmega3250__) || defined(__AVR_ATmega3290__) ||defined(__AVR_ATmega6450__) || d
 218:src/uart.c    ****  /* ATmega with one USART */
 219:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART_RX_vect
 220:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 221:src/uart.c    ****  #define UART0_STATUS      UCSR0A
 222:src/uart.c    ****  #define UART0_CONTROL     UCSR0B
 223:src/uart.c    ****  #define UART0_CONTROLC    UCSR0C
 224:src/uart.c    ****  #define UART0_DATA        UDR0
 225:src/uart.c    ****  #define UART0_UDRIE       UDRIE0
 226:src/uart.c    ****  #define UART0_UBRRL       UBRR0L
 227:src/uart.c    ****  #define UART0_UBRRH       UBRR0H
 228:src/uart.c    ****  #define UART0_BIT_U2X     U2X0
 229:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE0
 230:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN0
 231:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN0
 232:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ00
 233:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ01
 234:src/uart.c    **** #elif defined(__AVR_ATtiny2313__) || defined(__AVR_ATtiny2313A__) || defined(__AVR_ATtiny4313__)
 235:src/uart.c    ****  /* ATtiny with one USART */
 236:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART_RX_vect
 237:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 238:src/uart.c    ****  #define UART0_STATUS      UCSRA
 239:src/uart.c    ****  #define UART0_CONTROL     UCSRB
 240:src/uart.c    ****  #define UART0_CONTROLC    UCSRC
 241:src/uart.c    ****  #define UART0_DATA        UDR
 242:src/uart.c    ****  #define UART0_UDRIE       UDRIE
 243:src/uart.c    ****  #define UART0_UBRRL       UBRRL
 244:src/uart.c    ****  #define UART0_UBRRH       UBRRH
 245:src/uart.c    ****  #define UART0_BIT_U2X     U2X
 246:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE
 247:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN
 248:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN
 249:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ0
 250:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ1
 251:src/uart.c    **** #elif defined(__AVR_ATmega329__) || defined(__AVR_ATmega649__) || defined(__AVR_ATmega3290__) || de
 252:src/uart.c    ****       defined(__AVR_ATmega169A__) || defined(__AVR_ATmega169PA__) || \
 253:src/uart.c    ****       defined(__AVR_ATmega329A__) || defined(__AVR_ATmega329PA__) || defined(__AVR_ATmega3290A__) |
 254:src/uart.c    ****       defined(__AVR_ATmega649A__) || defined(__AVR_ATmega649P__) || defined(__AVR_ATmega6490A__) ||
 255:src/uart.c    ****       defined(__AVR_ATmega165__) || defined(__AVR_ATmega325__) || defined(__AVR_ATmega645__) || def
 256:src/uart.c    ****       defined(__AVR_ATmega165A__) || defined(__AVR_ATmega165PA__) || \
 257:src/uart.c    ****       defined(__AVR_ATmega325A__) || defined(__AVR_ATmega325PA__) || defined(__AVR_ATmega3250A__) |
 258:src/uart.c    ****       defined(__AVR_ATmega645A__) || defined(__AVR_ATmega645PA__) || defined(__AVR_ATmega6450A__) |
 259:src/uart.c    ****       defined(__AVR_ATmega644__)
 260:src/uart.c    ****  /* ATmega with one USART */
 261:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 262:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 263:src/uart.c    ****  #define UART0_STATUS      UCSR0A
 264:src/uart.c    ****  #define UART0_CONTROL     UCSR0B
 265:src/uart.c    ****  #define UART0_CONTROLC    UCSR0C
 266:src/uart.c    ****  #define UART0_DATA        UDR0
 267:src/uart.c    ****  #define UART0_UDRIE       UDRIE0
 268:src/uart.c    ****  #define UART0_UBRRL       UBRR0L
 269:src/uart.c    ****  #define UART0_UBRRH       UBRR0H
 270:src/uart.c    ****  #define UART0_BIT_U2X     U2X0
 271:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE0
 272:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN0
 273:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN0
 274:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ00
 275:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ01
 276:src/uart.c    **** #elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) || defined(__AVR_ATmega128A__) ||\
 277:src/uart.c    ****       defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || d
 278:src/uart.c    ****       defined(__AVR_ATmega164P__) || defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || 
 279:src/uart.c    ****       defined(__AVR_ATmega164A__) || defined(__AVR_ATmega164PA__) || defined(__AVR_ATmega324A__) ||
 280:src/uart.c    ****       defined(__AVR_ATmega644A__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284__) ||
 281:src/uart.c    ****       defined(__AVR_ATtiny1634__)
 282:src/uart.c    ****  /* ATmega with two USART */
 283:src/uart.c    ****  #define ATMEGA_USART1
 284:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 285:src/uart.c    ****  #define UART1_RECEIVE_INTERRUPT   USART1_RX_vect
 286:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 287:src/uart.c    ****  #define UART1_TRANSMIT_INTERRUPT  USART1_UDRE_vect
 288:src/uart.c    ****  #define UART0_STATUS      UCSR0A
 289:src/uart.c    ****  #define UART0_CONTROL     UCSR0B
 290:src/uart.c    ****  #define UART0_CONTROLC    UCSR0C  
 291:src/uart.c    ****  #define UART0_DATA        UDR0
 292:src/uart.c    ****  #define UART0_UDRIE       UDRIE0
 293:src/uart.c    ****  #define UART0_UBRRL       UBRR0L
 294:src/uart.c    ****  #define UART0_UBRRH       UBRR0H
 295:src/uart.c    ****  #define UART0_BIT_U2X     U2X0
 296:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE0
 297:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN0
 298:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN0
 299:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ00
 300:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ01 
 301:src/uart.c    ****  #define UART1_STATUS      UCSR1A
 302:src/uart.c    ****  #define UART1_CONTROL     UCSR1B
 303:src/uart.c    ****  #define UART1_CONTROLC    UCSR1C  
 304:src/uart.c    ****  #define UART1_DATA        UDR1
 305:src/uart.c    ****  #define UART1_UDRIE       UDRIE1
 306:src/uart.c    ****  #define UART1_UBRRL       UBRR1L
 307:src/uart.c    ****  #define UART1_UBRRH       UBRR1H
 308:src/uart.c    ****  #define UART1_BIT_U2X     U2X1
 309:src/uart.c    ****  #define UART1_BIT_RXCIE   RXCIE1
 310:src/uart.c    ****  #define UART1_BIT_RXEN    RXEN1
 311:src/uart.c    ****  #define UART1_BIT_TXEN    TXEN1
 312:src/uart.c    ****  #define UART1_BIT_UCSZ0   UCSZ10
 313:src/uart.c    ****  #define UART1_BIT_UCSZ1   UCSZ11
 314:src/uart.c    **** #elif defined(__AVR_ATmega8U2__) || defined(__AVR_ATmega16U2__) || defined(__AVR_ATmega32U2__) || \
 315:src/uart.c    ****       defined(__AVR_ATmega16U4__) || defined(__AVR_ATmega32U4__) || \
 316:src/uart.c    ****       defined(__AVR_AT90USB82__) || defined(__AVR_AT90USB162__) || \
 317:src/uart.c    ****       defined(__AVR_AT90USB646__) || defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB647__) ||
 318:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART1_RX_vect
 319:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART1_UDRE_vect
 320:src/uart.c    ****  #define UART0_STATUS      UCSR1A
 321:src/uart.c    ****  #define UART0_CONTROL     UCSR1B
 322:src/uart.c    ****  #define UART0_CONTROLC    UCSR1C
 323:src/uart.c    ****  #define UART0_DATA        UDR1
 324:src/uart.c    ****  #define UART0_UDRIE       UDRIE1
 325:src/uart.c    ****  #define UART0_UBRRL       UBRR1L
 326:src/uart.c    ****  #define UART0_UBRRH       UBRR1H
 327:src/uart.c    ****  #define UART0_BIT_U2X     U2X1
 328:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE1
 329:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN1
 330:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN1
 331:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ10
 332:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ11
 333:src/uart.c    **** #else
 334:src/uart.c    ****  #error "no UART definition for MCU available"
 335:src/uart.c    **** #endif
 336:src/uart.c    **** 
 337:src/uart.c    **** 
 338:src/uart.c    **** 
 339:src/uart.c    **** /*
 340:src/uart.c    ****  *  module global variables
 341:src/uart.c    ****  */
 342:src/uart.c    **** static volatile unsigned char UART_TxBuf[UART_TX_BUFFER_SIZE];
 343:src/uart.c    **** static volatile unsigned char UART_RxBuf[UART_RX_BUFFER_SIZE];
 344:src/uart.c    **** static volatile unsigned char UART_TxHead;
 345:src/uart.c    **** static volatile unsigned char UART_TxTail;
 346:src/uart.c    **** static volatile unsigned char UART_RxHead;
 347:src/uart.c    **** static volatile unsigned char UART_RxTail;
 348:src/uart.c    **** static volatile unsigned char UART_LastRxError;
 349:src/uart.c    **** 
 350:src/uart.c    **** #if defined( ATMEGA_USART1 )
 351:src/uart.c    **** static volatile unsigned char UART1_TxBuf[UART_TX_BUFFER_SIZE];
 352:src/uart.c    **** static volatile unsigned char UART1_RxBuf[UART_RX_BUFFER_SIZE];
 353:src/uart.c    **** static volatile unsigned char UART1_TxHead;
 354:src/uart.c    **** static volatile unsigned char UART1_TxTail;
 355:src/uart.c    **** static volatile unsigned char UART1_RxHead;
 356:src/uart.c    **** static volatile unsigned char UART1_RxTail;
 357:src/uart.c    **** static volatile unsigned char UART1_LastRxError;
 358:src/uart.c    **** #endif
 359:src/uart.c    **** 
 360:src/uart.c    **** 
 361:src/uart.c    **** 
 362:src/uart.c    **** ISR (UART0_RECEIVE_INTERRUPT)	
 363:src/uart.c    **** /*************************************************************************
 364:src/uart.c    **** Function: UART Receive Complete interrupt
 365:src/uart.c    **** Purpose:  called when the UART has received a character
 366:src/uart.c    **** **************************************************************************/
 367:src/uart.c    **** {
  15               		.loc 1 367 0
  16               		.cfi_startproc
  17 0000 1F92      		push r1
  18               	.LCFI0:
  19               		.cfi_def_cfa_offset 3
  20               		.cfi_offset 1, -2
  21 0002 0F92      		push r0
  22               	.LCFI1:
  23               		.cfi_def_cfa_offset 4
  24               		.cfi_offset 0, -3
  25 0004 0FB6      		in r0,__SREG__
  26 0006 0F92      		push r0
  27 0008 1124      		clr __zero_reg__
  28 000a 2F93      		push r18
  29               	.LCFI2:
  30               		.cfi_def_cfa_offset 5
  31               		.cfi_offset 18, -4
  32 000c 8F93      		push r24
  33               	.LCFI3:
  34               		.cfi_def_cfa_offset 6
  35               		.cfi_offset 24, -5
  36 000e 9F93      		push r25
  37               	.LCFI4:
  38               		.cfi_def_cfa_offset 7
  39               		.cfi_offset 25, -6
  40 0010 EF93      		push r30
  41               	.LCFI5:
  42               		.cfi_def_cfa_offset 8
  43               		.cfi_offset 30, -7
  44 0012 FF93      		push r31
  45               	.LCFI6:
  46               		.cfi_def_cfa_offset 9
  47               		.cfi_offset 31, -8
  48               	/* prologue: Signal */
  49               	/* frame size = 0 */
  50               	/* stack size = 8 */
  51               	.L__stack_usage = 8
 368:src/uart.c    ****     unsigned char tmphead;
 369:src/uart.c    ****     unsigned char data;
 370:src/uart.c    ****     unsigned char usr;
 371:src/uart.c    ****     unsigned char lastRxError;
 372:src/uart.c    ****  
 373:src/uart.c    ****  
 374:src/uart.c    ****     /* read UART status register and UART data register */
 375:src/uart.c    ****     usr  = UART0_STATUS;
  52               		.loc 1 375 0
  53 0014 8091 C000 		lds r24,192
  54               	.LVL0:
 376:src/uart.c    ****     data = UART0_DATA;
  55               		.loc 1 376 0
  56 0018 2091 C600 		lds r18,198
  57               	.LVL1:
 377:src/uart.c    ****     
 378:src/uart.c    ****     /* get FEn (Frame Error) DORn (Data OverRun) UPEn (USART Parity Error) bits */
 379:src/uart.c    **** #if defined(FE) && defined(DOR) && defined(UPE)
 380:src/uart.c    ****     lastRxError = usr & (_BV(FE)|_BV(DOR)|_BV(UPE) );
 381:src/uart.c    **** #elif defined(FE0) && defined(DOR0) && defined(UPE0)
 382:src/uart.c    ****     lastRxError = usr & (_BV(FE0)|_BV(DOR0)|_BV(UPE0) );
  58               		.loc 1 382 0
  59 001c 8C71      		andi r24,lo8(28)
  60               	.LVL2:
 383:src/uart.c    **** #elif defined(FE1) && defined(DOR1) && defined(UPE1)
 384:src/uart.c    ****     lastRxError = usr & (_BV(FE1)|_BV(DOR1)|_BV(UPE1) );
 385:src/uart.c    **** #elif defined(FE) && defined(DOR)
 386:src/uart.c    ****     lastRxError = usr & (_BV(FE)|_BV(DOR) );
 387:src/uart.c    **** #endif
 388:src/uart.c    **** 
 389:src/uart.c    ****     /* calculate buffer index */ 
 390:src/uart.c    ****     tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
  61               		.loc 1 390 0
  62 001e E091 0000 		lds r30,UART_RxHead
  63 0022 EF5F      		subi r30,lo8(-(1))
  64 0024 EF71      		andi r30,lo8(31)
  65               	.LVL3:
 391:src/uart.c    ****     
 392:src/uart.c    ****     if ( tmphead == UART_RxTail ) {
  66               		.loc 1 392 0
  67 0026 9091 0000 		lds r25,UART_RxTail
  68 002a E917      		cp r30,r25
  69 002c 01F0      		breq .L3
 393:src/uart.c    ****         /* error: receive buffer overflow */
 394:src/uart.c    ****         lastRxError = UART_BUFFER_OVERFLOW >> 8;
 395:src/uart.c    ****     }else{
 396:src/uart.c    ****         /* store new index */
 397:src/uart.c    ****         UART_RxHead = tmphead;
  70               		.loc 1 397 0
  71 002e E093 0000 		sts UART_RxHead,r30
 398:src/uart.c    ****         /* store received data in buffer */
 399:src/uart.c    ****         UART_RxBuf[tmphead] = data;
  72               		.loc 1 399 0
  73 0032 F0E0      		ldi r31,0
  74 0034 E050      		subi r30,lo8(-(UART_RxBuf))
  75 0036 F040      		sbci r31,hi8(-(UART_RxBuf))
  76               	.LVL4:
  77 0038 2083      		st Z,r18
  78               	.LVL5:
  79               	.L2:
 400:src/uart.c    ****     }
 401:src/uart.c    ****     UART_LastRxError |= lastRxError;   
  80               		.loc 1 401 0
  81 003a 9091 0000 		lds r25,UART_LastRxError
  82 003e 892B      		or r24,r25
  83               	.LVL6:
  84 0040 8093 0000 		sts UART_LastRxError,r24
  85               	/* epilogue start */
 402:src/uart.c    **** }
  86               		.loc 1 402 0
  87 0044 FF91      		pop r31
  88 0046 EF91      		pop r30
  89 0048 9F91      		pop r25
  90 004a 8F91      		pop r24
  91 004c 2F91      		pop r18
  92               	.LVL7:
  93 004e 0F90      		pop r0
  94 0050 0FBE      		out __SREG__,r0
  95 0052 0F90      		pop r0
  96 0054 1F90      		pop r1
  97 0056 1895      		reti
  98               	.LVL8:
  99               	.L3:
 394:src/uart.c    ****     }else{
 100               		.loc 1 394 0
 101 0058 82E0      		ldi r24,lo8(2)
 102               	.LVL9:
 103 005a 00C0      		rjmp .L2
 104               		.cfi_endproc
 105               	.LFE1:
 107               	.global	__vector_19
 109               	__vector_19:
 110               	.LFB2:
 403:src/uart.c    **** 
 404:src/uart.c    **** 
 405:src/uart.c    **** ISR (UART0_TRANSMIT_INTERRUPT)
 406:src/uart.c    **** /*************************************************************************
 407:src/uart.c    **** Function: UART Data Register Empty interrupt
 408:src/uart.c    **** Purpose:  called when the UART is ready to transmit the next byte
 409:src/uart.c    **** **************************************************************************/
 410:src/uart.c    **** {
 111               		.loc 1 410 0
 112               		.cfi_startproc
 113 005c 1F92      		push r1
 114               	.LCFI7:
 115               		.cfi_def_cfa_offset 3
 116               		.cfi_offset 1, -2
 117 005e 0F92      		push r0
 118               	.LCFI8:
 119               		.cfi_def_cfa_offset 4
 120               		.cfi_offset 0, -3
 121 0060 0FB6      		in r0,__SREG__
 122 0062 0F92      		push r0
 123 0064 1124      		clr __zero_reg__
 124 0066 8F93      		push r24
 125               	.LCFI9:
 126               		.cfi_def_cfa_offset 5
 127               		.cfi_offset 24, -4
 128 0068 9F93      		push r25
 129               	.LCFI10:
 130               		.cfi_def_cfa_offset 6
 131               		.cfi_offset 25, -5
 132 006a EF93      		push r30
 133               	.LCFI11:
 134               		.cfi_def_cfa_offset 7
 135               		.cfi_offset 30, -6
 136 006c FF93      		push r31
 137               	.LCFI12:
 138               		.cfi_def_cfa_offset 8
 139               		.cfi_offset 31, -7
 140               	/* prologue: Signal */
 141               	/* frame size = 0 */
 142               	/* stack size = 7 */
 143               	.L__stack_usage = 7
 411:src/uart.c    ****     unsigned char tmptail;
 412:src/uart.c    **** 
 413:src/uart.c    ****     
 414:src/uart.c    ****     if ( UART_TxHead != UART_TxTail) {
 144               		.loc 1 414 0
 145 006e 9091 0000 		lds r25,UART_TxHead
 146 0072 8091 0000 		lds r24,UART_TxTail
 147 0076 9817      		cp r25,r24
 148 0078 01F0      		breq .L6
 415:src/uart.c    ****         /* calculate and store new buffer index */
 416:src/uart.c    ****         tmptail = (UART_TxTail + 1) & UART_TX_BUFFER_MASK;
 149               		.loc 1 416 0
 150 007a E091 0000 		lds r30,UART_TxTail
 151 007e EF5F      		subi r30,lo8(-(1))
 152 0080 EF71      		andi r30,lo8(31)
 153               	.LVL10:
 417:src/uart.c    ****         UART_TxTail = tmptail;
 154               		.loc 1 417 0
 155 0082 E093 0000 		sts UART_TxTail,r30
 418:src/uart.c    ****         /* get one byte from buffer and write it to UART */
 419:src/uart.c    ****         UART0_DATA = UART_TxBuf[tmptail];  /* start transmission */
 156               		.loc 1 419 0
 157 0086 F0E0      		ldi r31,0
 158 0088 E050      		subi r30,lo8(-(UART_TxBuf))
 159 008a F040      		sbci r31,hi8(-(UART_TxBuf))
 160               	.LVL11:
 161 008c 8081      		ld r24,Z
 162 008e 8093 C600 		sts 198,r24
 163               	.LVL12:
 164               	.L5:
 165               	/* epilogue start */
 420:src/uart.c    ****     }else{
 421:src/uart.c    ****         /* tx buffer empty, disable UDRE interrupt */
 422:src/uart.c    ****         UART0_CONTROL &= ~_BV(UART0_UDRIE);
 423:src/uart.c    ****     }
 424:src/uart.c    **** }
 166               		.loc 1 424 0
 167 0092 FF91      		pop r31
 168 0094 EF91      		pop r30
 169 0096 9F91      		pop r25
 170 0098 8F91      		pop r24
 171 009a 0F90      		pop r0
 172 009c 0FBE      		out __SREG__,r0
 173 009e 0F90      		pop r0
 174 00a0 1F90      		pop r1
 175 00a2 1895      		reti
 176               	.L6:
 422:src/uart.c    ****     }
 177               		.loc 1 422 0
 178 00a4 8091 C100 		lds r24,193
 179 00a8 8F7D      		andi r24,lo8(-33)
 180 00aa 8093 C100 		sts 193,r24
 181               		.loc 1 424 0
 182 00ae 00C0      		rjmp .L5
 183               		.cfi_endproc
 184               	.LFE2:
 186               	.global	uart_init
 188               	uart_init:
 189               	.LFB3:
 425:src/uart.c    **** 
 426:src/uart.c    **** 
 427:src/uart.c    **** /*************************************************************************
 428:src/uart.c    **** Function: uart_init()
 429:src/uart.c    **** Purpose:  initialize UART and set baudrate
 430:src/uart.c    **** Input:    baudrate using macro UART_BAUD_SELECT()
 431:src/uart.c    **** Returns:  none
 432:src/uart.c    **** **************************************************************************/
 433:src/uart.c    **** void uart_init(unsigned int baudrate)
 434:src/uart.c    **** {
 190               		.loc 1 434 0
 191               		.cfi_startproc
 192               	.LVL13:
 193               	/* prologue: function */
 194               	/* frame size = 0 */
 195               	/* stack size = 0 */
 196               	.L__stack_usage = 0
 435:src/uart.c    ****     UART_TxHead = 0;
 197               		.loc 1 435 0
 198 00b0 1092 0000 		sts UART_TxHead,__zero_reg__
 436:src/uart.c    ****     UART_TxTail = 0;
 199               		.loc 1 436 0
 200 00b4 1092 0000 		sts UART_TxTail,__zero_reg__
 437:src/uart.c    ****     UART_RxHead = 0;
 201               		.loc 1 437 0
 202 00b8 1092 0000 		sts UART_RxHead,__zero_reg__
 438:src/uart.c    ****     UART_RxTail = 0;
 203               		.loc 1 438 0
 204 00bc 1092 0000 		sts UART_RxTail,__zero_reg__
 439:src/uart.c    **** 
 440:src/uart.c    **** #ifdef UART_TEST
 441:src/uart.c    **** #ifndef UART0_BIT_U2X
 442:src/uart.c    **** #warning "UART0_BIT_U2X not defined"
 443:src/uart.c    **** #endif
 444:src/uart.c    **** #ifndef UART0_UBRRH
 445:src/uart.c    **** #warning "UART0_UBRRH not defined"
 446:src/uart.c    **** #endif
 447:src/uart.c    **** #ifndef UART0_CONTROLC
 448:src/uart.c    **** #warning "UART0_CONTROLC not defined"
 449:src/uart.c    **** #endif
 450:src/uart.c    **** #if defined(URSEL) || defined(URSEL0)
 451:src/uart.c    **** #ifndef UART0_BIT_URSEL
 452:src/uart.c    **** #warning "UART0_BIT_URSEL not defined"
 453:src/uart.c    **** #endif
 454:src/uart.c    **** #endif
 455:src/uart.c    **** #endif
 456:src/uart.c    **** 
 457:src/uart.c    ****     /* Set baud rate */
 458:src/uart.c    ****     if ( baudrate & 0x8000 )
 205               		.loc 1 458 0
 206 00c0 97FF      		sbrs r25,7
 207 00c2 00C0      		rjmp .L9
 459:src/uart.c    ****     {
 460:src/uart.c    ****         #if UART0_BIT_U2X
 461:src/uart.c    ****         UART0_STATUS = (1<<UART0_BIT_U2X);  //Enable 2x speed 
 208               		.loc 1 461 0
 209 00c4 22E0      		ldi r18,lo8(2)
 210 00c6 2093 C000 		sts 192,r18
 211               	.L9:
 462:src/uart.c    ****         #endif
 463:src/uart.c    ****     } 
 464:src/uart.c    ****     #if defined(UART0_UBRRH)
 465:src/uart.c    ****     UART0_UBRRH = (unsigned char)((baudrate>>8)&0x80) ;
 212               		.loc 1 465 0
 213 00ca 9078      		andi r25,lo8(-128)
 214 00cc 9093 C500 		sts 197,r25
 466:src/uart.c    ****     #endif    
 467:src/uart.c    ****     UART0_UBRRL = (unsigned char) (baudrate&0x00FF);
 215               		.loc 1 467 0
 216 00d0 8093 C400 		sts 196,r24
 468:src/uart.c    ****       
 469:src/uart.c    ****     /* Enable USART receiver and transmitter and receive complete interrupt */
 470:src/uart.c    ****     UART0_CONTROL = _BV(UART0_BIT_RXCIE)|(1<<UART0_BIT_RXEN)|(1<<UART0_BIT_TXEN);
 217               		.loc 1 470 0
 218 00d4 88E9      		ldi r24,lo8(-104)
 219               	.LVL14:
 220 00d6 8093 C100 		sts 193,r24
 471:src/uart.c    ****     
 472:src/uart.c    ****     /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
 473:src/uart.c    ****     #ifdef UART0_CONTROLC
 474:src/uart.c    ****     #ifdef UART0_BIT_URSEL
 475:src/uart.c    ****     UART0_CONTROLC = (1<<UART0_BIT_URSEL)|(1<<UART0_BIT_UCSZ1)|(1<<UART0_BIT_UCSZ0);
 476:src/uart.c    ****     #else
 477:src/uart.c    ****     UART0_CONTROLC = (1<<UART0_BIT_UCSZ1)|(1<<UART0_BIT_UCSZ0);
 221               		.loc 1 477 0
 222 00da 86E0      		ldi r24,lo8(6)
 223 00dc 8093 C200 		sts 194,r24
 224 00e0 0895      		ret
 225               		.cfi_endproc
 226               	.LFE3:
 228               	.global	uart_getc
 230               	uart_getc:
 231               	.LFB4:
 478:src/uart.c    ****     #endif 
 479:src/uart.c    ****     #endif
 480:src/uart.c    **** 
 481:src/uart.c    **** }/* uart_init */
 482:src/uart.c    **** 
 483:src/uart.c    **** 
 484:src/uart.c    **** /*************************************************************************
 485:src/uart.c    **** Function: uart_getc()
 486:src/uart.c    **** Purpose:  return byte from ringbuffer  
 487:src/uart.c    **** Returns:  lower byte:  received byte from ringbuffer
 488:src/uart.c    ****           higher byte: last receive error
 489:src/uart.c    **** **************************************************************************/
 490:src/uart.c    **** unsigned int uart_getc(void)
 491:src/uart.c    **** {    
 232               		.loc 1 491 0
 233               		.cfi_startproc
 234               	/* prologue: function */
 235               	/* frame size = 0 */
 236               	/* stack size = 0 */
 237               	.L__stack_usage = 0
 492:src/uart.c    ****     unsigned char tmptail;
 493:src/uart.c    ****     unsigned char data;
 494:src/uart.c    ****     unsigned char lastRxError;
 495:src/uart.c    **** 
 496:src/uart.c    **** 
 497:src/uart.c    ****     if ( UART_RxHead == UART_RxTail ) {
 238               		.loc 1 497 0
 239 00e2 9091 0000 		lds r25,UART_RxHead
 240 00e6 8091 0000 		lds r24,UART_RxTail
 241 00ea 9817      		cp r25,r24
 242 00ec 01F0      		breq .L12
 498:src/uart.c    ****         return UART_NO_DATA;   /* no data available */
 499:src/uart.c    ****     }
 500:src/uart.c    ****     
 501:src/uart.c    ****     /* calculate buffer index */
 502:src/uart.c    ****     tmptail = (UART_RxTail + 1) & UART_RX_BUFFER_MASK;
 243               		.loc 1 502 0
 244 00ee 9091 0000 		lds r25,UART_RxTail
 245 00f2 9F5F      		subi r25,lo8(-(1))
 246 00f4 9F71      		andi r25,lo8(31)
 247               	.LVL15:
 503:src/uart.c    ****     
 504:src/uart.c    ****     /* get data from receive buffer */
 505:src/uart.c    ****     data = UART_RxBuf[tmptail];
 248               		.loc 1 505 0
 249 00f6 E92F      		mov r30,r25
 250 00f8 F0E0      		ldi r31,0
 251 00fa E050      		subi r30,lo8(-(UART_RxBuf))
 252 00fc F040      		sbci r31,hi8(-(UART_RxBuf))
 253 00fe 2081      		ld r18,Z
 254               	.LVL16:
 506:src/uart.c    ****     lastRxError = UART_LastRxError;
 255               		.loc 1 506 0
 256 0100 8091 0000 		lds r24,UART_LastRxError
 257               	.LVL17:
 507:src/uart.c    ****     
 508:src/uart.c    ****     /* store buffer index */
 509:src/uart.c    ****     UART_RxTail = tmptail; 
 258               		.loc 1 509 0
 259 0104 9093 0000 		sts UART_RxTail,r25
 510:src/uart.c    ****     
 511:src/uart.c    ****     UART_LastRxError = 0;
 260               		.loc 1 511 0
 261 0108 1092 0000 		sts UART_LastRxError,__zero_reg__
 512:src/uart.c    ****     return (lastRxError << 8) + data;
 262               		.loc 1 512 0
 263 010c 90E0      		ldi r25,0
 264               	.LVL18:
 265 010e 982F      		mov r25,r24
 266 0110 8827      		clr r24
 267               	.LVL19:
 268 0112 820F      		add r24,r18
 269 0114 911D      		adc r25,__zero_reg__
 270 0116 0895      		ret
 271               	.LVL20:
 272               	.L12:
 498:src/uart.c    ****     }
 273               		.loc 1 498 0
 274 0118 80E0      		ldi r24,0
 275 011a 91E0      		ldi r25,lo8(1)
 513:src/uart.c    **** 
 514:src/uart.c    **** }/* uart_getc */
 276               		.loc 1 514 0
 277 011c 0895      		ret
 278               		.cfi_endproc
 279               	.LFE4:
 281               	.global	uart_putc
 283               	uart_putc:
 284               	.LFB5:
 515:src/uart.c    **** 
 516:src/uart.c    **** 
 517:src/uart.c    **** /*************************************************************************
 518:src/uart.c    **** Function: uart_putc()
 519:src/uart.c    **** Purpose:  write byte to ringbuffer for transmitting via UART
 520:src/uart.c    **** Input:    byte to be transmitted
 521:src/uart.c    **** Returns:  none          
 522:src/uart.c    **** **************************************************************************/
 523:src/uart.c    **** void uart_putc(unsigned char data)
 524:src/uart.c    **** {
 285               		.loc 1 524 0
 286               		.cfi_startproc
 287               	.LVL21:
 288               	/* prologue: function */
 289               	/* frame size = 0 */
 290               	/* stack size = 0 */
 291               	.L__stack_usage = 0
 525:src/uart.c    ****     unsigned char tmphead;
 526:src/uart.c    **** 
 527:src/uart.c    ****     
 528:src/uart.c    ****     tmphead  = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
 292               		.loc 1 528 0
 293 011e 2091 0000 		lds r18,UART_TxHead
 294 0122 2F5F      		subi r18,lo8(-(1))
 295 0124 2F71      		andi r18,lo8(31)
 296               	.LVL22:
 297               	.L14:
 529:src/uart.c    ****     
 530:src/uart.c    ****     while ( tmphead == UART_TxTail ){
 298               		.loc 1 530 0 discriminator 1
 299 0126 9091 0000 		lds r25,UART_TxTail
 300 012a 2917      		cp r18,r25
 301 012c 01F0      		breq .L14
 531:src/uart.c    ****         ;/* wait for free space in buffer */
 532:src/uart.c    ****     }
 533:src/uart.c    ****     
 534:src/uart.c    ****     UART_TxBuf[tmphead] = data;
 302               		.loc 1 534 0
 303 012e E22F      		mov r30,r18
 304 0130 F0E0      		ldi r31,0
 305 0132 E050      		subi r30,lo8(-(UART_TxBuf))
 306 0134 F040      		sbci r31,hi8(-(UART_TxBuf))
 307 0136 8083      		st Z,r24
 535:src/uart.c    ****     UART_TxHead = tmphead;
 308               		.loc 1 535 0
 309 0138 2093 0000 		sts UART_TxHead,r18
 536:src/uart.c    **** 
 537:src/uart.c    ****     /* enable UDRE interrupt */
 538:src/uart.c    ****     UART0_CONTROL    |= _BV(UART0_UDRIE);
 310               		.loc 1 538 0
 311 013c 8091 C100 		lds r24,193
 312               	.LVL23:
 313 0140 8062      		ori r24,lo8(32)
 314 0142 8093 C100 		sts 193,r24
 315 0146 0895      		ret
 316               		.cfi_endproc
 317               	.LFE5:
 319               	.global	uart_puts
 321               	uart_puts:
 322               	.LFB6:
 539:src/uart.c    **** 
 540:src/uart.c    **** }/* uart_putc */
 541:src/uart.c    **** 
 542:src/uart.c    **** 
 543:src/uart.c    **** /*************************************************************************
 544:src/uart.c    **** Function: uart_puts()
 545:src/uart.c    **** Purpose:  transmit string to UART
 546:src/uart.c    **** Input:    string to be transmitted
 547:src/uart.c    **** Returns:  none          
 548:src/uart.c    **** **************************************************************************/
 549:src/uart.c    **** void uart_puts(const char *s )
 550:src/uart.c    **** {
 323               		.loc 1 550 0
 324               		.cfi_startproc
 325               	.LVL24:
 326               	/* prologue: function */
 327               	/* frame size = 0 */
 328               	/* stack size = 0 */
 329               	.L__stack_usage = 0
 551:src/uart.c    ****     while (*s) 
 330               		.loc 1 551 0
 331 0148 FC01      		movw r30,r24
 332 014a 3081      		ld r19,Z
 333 014c 3323      		tst r19
 334 014e 01F0      		breq .L16
 335 0150 DC01      		movw r26,r24
 336 0152 1196      		adiw r26,1
 337               	.LVL25:
 338               	.L19:
 339               	.LBB7:
 340               	.LBB8:
 528:src/uart.c    ****     
 341               		.loc 1 528 0
 342 0154 2091 0000 		lds r18,UART_TxHead
 343 0158 2F5F      		subi r18,lo8(-(1))
 344 015a 2F71      		andi r18,lo8(31)
 345               	.LVL26:
 346               	.L18:
 530:src/uart.c    ****         ;/* wait for free space in buffer */
 347               		.loc 1 530 0
 348 015c 9091 0000 		lds r25,UART_TxTail
 349 0160 2917      		cp r18,r25
 350 0162 01F0      		breq .L18
 534:src/uart.c    ****     UART_TxHead = tmphead;
 351               		.loc 1 534 0
 352 0164 E22F      		mov r30,r18
 353 0166 F0E0      		ldi r31,0
 354 0168 E050      		subi r30,lo8(-(UART_TxBuf))
 355 016a F040      		sbci r31,hi8(-(UART_TxBuf))
 356 016c 3083      		st Z,r19
 535:src/uart.c    **** 
 357               		.loc 1 535 0
 358 016e 2093 0000 		sts UART_TxHead,r18
 538:src/uart.c    **** 
 359               		.loc 1 538 0
 360 0172 9091 C100 		lds r25,193
 361 0176 9062      		ori r25,lo8(32)
 362 0178 9093 C100 		sts 193,r25
 363               	.LBE8:
 364               	.LBE7:
 365               		.loc 1 551 0
 366 017c 3D91      		ld r19,X+
 367               	.LVL27:
 368 017e 3111      		cpse r19,__zero_reg__
 369 0180 00C0      		rjmp .L19
 370               	.LVL28:
 371               	.L16:
 372 0182 0895      		ret
 373               		.cfi_endproc
 374               	.LFE6:
 376               	.global	uart_puts_p
 378               	uart_puts_p:
 379               	.LFB7:
 552:src/uart.c    ****       uart_putc(*s++);
 553:src/uart.c    **** 
 554:src/uart.c    **** }/* uart_puts */
 555:src/uart.c    **** 
 556:src/uart.c    **** 
 557:src/uart.c    **** /*************************************************************************
 558:src/uart.c    **** Function: uart_puts_p()
 559:src/uart.c    **** Purpose:  transmit string from program memory to UART
 560:src/uart.c    **** Input:    program memory string to be transmitted
 561:src/uart.c    **** Returns:  none
 562:src/uart.c    **** **************************************************************************/
 563:src/uart.c    **** void uart_puts_p(const char *progmem_s )
 564:src/uart.c    **** {
 380               		.loc 1 564 0
 381               		.cfi_startproc
 382               	.LVL29:
 383               	/* prologue: function */
 384               	/* frame size = 0 */
 385               	/* stack size = 0 */
 386               	.L__stack_usage = 0
 387               	.LBB9:
 565:src/uart.c    ****     register char c;
 566:src/uart.c    ****     
 567:src/uart.c    ****     while ( (c = pgm_read_byte(progmem_s++)) ) 
 388               		.loc 1 567 0
 389 0184 AC01      		movw r20,r24
 390 0186 4F5F      		subi r20,-1
 391 0188 5F4F      		sbci r21,-1
 392               	.LVL30:
 393 018a FC01      		movw r30,r24
 394               	/* #APP */
 395               	 ;  567 "src/uart.c" 1
 396 018c 2491      		lpm r18, Z
 397               		
 398               	 ;  0 "" 2
 399               	.LVL31:
 400               	/* #NOAPP */
 401               	.LBE9:
 402 018e 2223      		tst r18
 403 0190 01F0      		breq .L23
 404 0192 FA01      		movw r30,r20
 405               	.LVL32:
 406               	.L26:
 407               	.LBB10:
 408               	.LBB11:
 528:src/uart.c    ****     
 409               		.loc 1 528 0
 410 0194 9091 0000 		lds r25,UART_TxHead
 411 0198 9F5F      		subi r25,lo8(-(1))
 412 019a 9F71      		andi r25,lo8(31)
 413               	.LVL33:
 414               	.L25:
 530:src/uart.c    ****         ;/* wait for free space in buffer */
 415               		.loc 1 530 0
 416 019c 8091 0000 		lds r24,UART_TxTail
 417 01a0 9817      		cp r25,r24
 418 01a2 01F0      		breq .L25
 534:src/uart.c    ****     UART_TxHead = tmphead;
 419               		.loc 1 534 0
 420 01a4 A92F      		mov r26,r25
 421 01a6 B0E0      		ldi r27,0
 422 01a8 A050      		subi r26,lo8(-(UART_TxBuf))
 423 01aa B040      		sbci r27,hi8(-(UART_TxBuf))
 424 01ac 2C93      		st X,r18
 535:src/uart.c    **** 
 425               		.loc 1 535 0
 426 01ae 9093 0000 		sts UART_TxHead,r25
 538:src/uart.c    **** 
 427               		.loc 1 538 0
 428 01b2 8091 C100 		lds r24,193
 429 01b6 8062      		ori r24,lo8(32)
 430 01b8 8093 C100 		sts 193,r24
 431               	.LVL34:
 432               	.LBE11:
 433               	.LBE10:
 434               	.LBB12:
 435               		.loc 1 567 0
 436               	/* #APP */
 437               	 ;  567 "src/uart.c" 1
 438 01bc 2491      		lpm r18, Z
 439               		
 440               	 ;  0 "" 2
 441               	.LVL35:
 442               	/* #NOAPP */
 443 01be 3196      		adiw r30,1
 444               	.LVL36:
 445               	.LBE12:
 446 01c0 2111      		cpse r18,__zero_reg__
 447 01c2 00C0      		rjmp .L26
 448               	.LVL37:
 449               	.L23:
 450 01c4 0895      		ret
 451               		.cfi_endproc
 452               	.LFE7:
 454               		.local	UART_LastRxError
 455               		.comm	UART_LastRxError,1,1
 456               		.local	UART_RxTail
 457               		.comm	UART_RxTail,1,1
 458               		.local	UART_RxHead
 459               		.comm	UART_RxHead,1,1
 460               		.local	UART_TxTail
 461               		.comm	UART_TxTail,1,1
 462               		.local	UART_TxHead
 463               		.comm	UART_TxHead,1,1
 464               		.local	UART_RxBuf
 465               		.comm	UART_RxBuf,32,1
 466               		.local	UART_TxBuf
 467               		.comm	UART_TxBuf,32,1
 468               	.Letext0:
 469               		.file 2 "/usr/lib/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 uart.c
     /tmp/cc347PWM.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc347PWM.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc347PWM.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc347PWM.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc347PWM.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc347PWM.s:12     .text:0000000000000000 __vector_18
     /tmp/cc347PWM.s:457    .bss:0000000000000002 UART_RxHead
     /tmp/cc347PWM.s:455    .bss:0000000000000001 UART_RxTail
     /tmp/cc347PWM.s:463    .bss:0000000000000005 UART_RxBuf
                             .bss:0000000000000000 UART_LastRxError
     /tmp/cc347PWM.s:109    .text:000000000000005c __vector_19
     /tmp/cc347PWM.s:461    .bss:0000000000000004 UART_TxHead
     /tmp/cc347PWM.s:459    .bss:0000000000000003 UART_TxTail
     /tmp/cc347PWM.s:465    .bss:0000000000000025 UART_TxBuf
     /tmp/cc347PWM.s:188    .text:00000000000000b0 uart_init
     /tmp/cc347PWM.s:230    .text:00000000000000e2 uart_getc
     /tmp/cc347PWM.s:283    .text:000000000000011e uart_putc
     /tmp/cc347PWM.s:321    .text:0000000000000148 uart_puts
     /tmp/cc347PWM.s:378    .text:0000000000000184 uart_puts_p

UNDEFINED SYMBOLS
__do_clear_bss
